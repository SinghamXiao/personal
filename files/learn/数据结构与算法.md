####1、二叉搜索树

    在二叉查找树中：
        
        1. 任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值。
        
        2. 任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值。
        
        3. 任意节点的左、右子树也分别为二叉查找树。
        
        4. 没有键值相等的节点（no duplicate nodes）。
    
    前驱节点：节点val值小于该节点val值并且值最大的节点
    
        若一个节点有左子树，那么该节点的前驱节点是其左子树中val值最大的节点（也就是左子树中所谓的rightMostNode）。
        
        若一个节点没有左子树，那么判断该节点和其父节点的关系：
        
            若该节点是其父节点的右边孩子，那么该节点的前驱节点即为其父节点。
        
            若该节点是其父节点的左边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的右边孩子（可参考例子2的前驱节点是1），那么Q就是该节点的后继节点
    
    后继节点：节点val值大于该节点val值并且值最小的节点
    
        若一个节点有右子树，那么该节点的后继节点是其右子树中val值最小的节点（也就是右子树中所谓的leftMostNode）。
        
        若一个节点没有右子树，那么判断该节点和其父节点的关系：
            
            若该节点是其父节点的左边孩子，那么该节点的后继节点即为其父节点
            
            若该节点是其父节点的右边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的左边孩子（可参考例子2的前驱节点是1），那么Q就是该节点的后继节点
    
    删除节点：
    
        1. 被删除节点没有子树的情况，直接删除，并修改对应父节点的指针为空。
    
        2. 对于只有一个子树的情况，考虑将其子树作为其父节点的子树，关于是左还是右，根据被删除的节点确定。
    
        3. 最复杂的是有两个子数的情况，可以考虑两种方法，都是同样的思想：用被删除节点A的左子树的最右节点或者A的右子树的最左节点作为替代A的节点，并修改相应的最左或最右节点的父节点的指针，修改方法类似2。

####2、红黑树

    特性：
    
        1. 每个节点或者是黑色，或者是红色。
        
        2. 根节点是黑色。
        
        3. 每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
        
        4. 如果一个节点是红色的，则它的子节点必须是黑色的（反之，不一定成立）。
        
        5. 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。
    
    注意：
        
        特性(3)中的叶子节点，是只为空(NIL或null)的节点。
        
        特性(5)确保没有一条路径会比其他路径长出2倍。因而，红黑树是相对是接近平衡的二叉树。
    
    左旋操作：
                     
        * 左旋示意图：对节点x进行左旋 
        *     p                       p 
        *    /                       / 
        *   x                       y 
        *  / \                     / \ 
        * lx  y      ----->       x  ry 
        *    / \                 / \ 
        *   ly ry               lx ly
     
        1. 将y的左子节点赋给x的右子节点,并将x赋给y左子节点的父节点(y左子节点非空时) 
        
        2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右) 
        
        3. 将y的左子节点设为x，将x的父节点设为y
         
    右旋操作：
    
        * 右旋示意图：对节点y进行右旋 
        *        p                   p 
        *       /                   / 
        *      y                   x 
        *     / \                 / \ 
        *    x  ry   ----->      lx  y 
        *   / \                     / \ 
        * lx  rx                   rx ry
        
        1. 将x的右子节点赋给y的左子节点,并将y赋给x右子节点的父节点(x右子节点非空时) 
        
        2. 将y的父节点p(非空时)赋给x的父节点，同时更新p的子节点为x(左或右) 
        
        3. 将x的右子节点设为y，将y的父节点设为x 
         
    插入操作：
    
        如果是第一次插入，由于原树为空，所以只会违反红-黑树的规则2，所以只要把根节点涂黑即可；
        
        如果插入节点的父节点是黑色的，那不会违背红-黑树的规则，什么也不需要做；但是遇到如下三种情况时，就需要变色和旋转了：
        
            1. 插入节点的父节点和其叔叔节点（祖父节点的另一个子节点）均为红色的：
            
                处理：将当前节点(4)的父节点(5)和叔叔节点(8)涂黑，将祖父节点(7)涂红。再将当前节点指向其祖父节点，再次从新的当前节点开始算法；
        
            2. 插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的右子节点：
            
                处理：将当前节点(7)的父节点(2)作为新的节点，以新的当前节点为支点做左旋操作；
        
            3. 插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的左子节点：
            
                处理：将当前节点的父节点(7)涂黑，将祖父节点(11)涂红，在祖父节点为支点做右旋操作。
        总结：
        
            变色和旋转之间的先后关系可以表示为：变色 --> 左旋 --> 右旋
    
    删除操作：
    
        同二叉搜索树的删除，再做计算：
        
            删除某个节点后，会用它的后继节点来填上，并且后继节点会设置为和删除节点同样的颜色，所以删除节点的那个位置是不会破坏平衡的。
            
            可能破坏平衡的是后继节点原来的位置，因为后继节点拿走了，原来的位置结构改变了，这就会导致不平衡的出现。所以removeFixUp方法中传入的参数也是后继节点的子节点和父节点。
            
                为了方便下文的叙述，我们现在约定：后继节点的子节点称为“当前节点”。删除操作后，
                
                    如果当前节点是黑色的根节点，那么不用任何操作，因为并没有破坏树的平衡性，即没有违背红-黑树的规则。
                    
                    如果当前节点是红色的，说明刚刚移走的后继节点是黑色的，那么不管后继节点的父节点是啥颜色，我们只要将当前节点涂黑就可以了，红-黑树的平衡性就可以恢复。（删除的黑色节点仅有左子树或者仅有右子树）
                    
                    如果遇到以下四种情况，我们就需要通过变色或旋转来恢复红-黑树的平衡了：
                
                        1. 当前节点是黑色的，且兄弟节点是红色的（那么父节点和兄弟节点的子节点肯定是黑色的）；
                
                        2. 当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的两个子节点均为黑色的；
                
                        3. 当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的左子节点是红色，右子节点时黑色的；
                
                        4. 当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的右子节点是红色，左子节点任意颜色。
        总结：
         
            如果是从情况1开始发生的，可能情况2、情况3、情况4中的一种；
            
            如果是情况2，就不可能再出现情况3和情况4；
            
            如果是情况3，必然会导致情况4的出现；
            
            如果情况2和情况3都不是，那必然是情况4。
    
    参考资料：www.cnblogs.com/skywang12345/p/3603935.html