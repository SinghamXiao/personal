1、RPC（Remote Procedure Call）：

首先了解什么叫RPC，为什么要RPC，RPC是指远程过程调用，也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。

比如说，一个方法可能是这样定义的：

Employee getEmployeeByName(String fullName)

那么：

	首先，要解决通讯的问题，主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。

	第二，要解决寻址的问题，也就是说，A服务器上的应用怎么告诉底层的RPC框架，如何连接到B服务器（如主机或IP地址）以及特定的端口，方法的名称名称是什么，这样才能完成调用。比如基于Web服务协议栈的RPC，就要提供一个endpoint URI，或者是从UDDI服务上查找。如果是RMI调用的话，还需要一个RMI Registry来注册服务的地址。

	第三，当A服务器上的应用发起远程过程调用时，方法的参数需要通过底层的网络协议如TCP传递到B服务器，由于网络协议是基于二进制的，内存中的参数的值要序列化成二进制的形式，也就是序列化（Serialize）或编组（marshal），通过寻址和传输将序列化的二进制发送给B服务器。

	第四，B服务器收到请求后，需要对参数进行反序列化（序列化的逆操作），恢复为内存中的表达方式，然后找到对应的方法（寻址的一部分）进行本地调用，然后得到返回值。

	第五，返回值还要发送回服务器A上的应用，也要经过序列化的方式发送，服务器A接到后，再反序列化，恢复为内存中的表达方式，交给A服务器上的应用。

为什么RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如比如不同的系统间的通讯，甚至不同的组织间的通讯。由于计算能力需要横向扩展，需要 在多台机器组成的集群上部署应用，

RPC的协议有很多，比如最早的CORBA，Java RMI，Web Service的RPC风格，Hessian，Thrift，甚至Rest API。
	
实现 RPC 的程序包括 5 个部分：

    1. User
	
    2. User-stub
	
    3. RPCRuntime
	
    4. Server-stub
	
    5. Server
	
	这里 user 就是 client 端，当 user 想发起一个远程调用时，它实际是通过本地调用 user-stub。user-stub 负责将调用的接口、方法和参数通过约定的协议规范进行编码并通过本地的 RPCRuntime 实例传输到远端的实例。远端 RPCRuntime 实例收到请求后交给 server-stub 进行解码后发起本地端调用，调用结果再返回给 user 端。
	
	
RPC功能目标：

RPC的主要功能目标是让构建分布式计算（应用）更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。为实现该目标，RPC 框架需提供一种透明调用机制让使用者不必显式的区分本地调用和远程调用，在前文《浅出篇》中给出了一种实现结构，基于 stub 的结构来实现。下面我们将具体细化 stub 结构的实现

RPC的调用类型：

	1. 同步调用
	
	   客户方等待调用执行完成并返回结果。
	   
	2. 异步调用
	
	   客户方调用后不用等待执行结果返回，但依然可以通过回调通知等方式获取返回结果。
	   
	   若客户方不关心调用返回结果，则变成单向异步调用，单向调用不用返回结果。

异步和同步的区分在于是否等待服务端执行完成并返回结果。

RPC 实现结构的各个组件组成部分以及职责划分：

	1. RpcServer  
	   负责导出（export）远程接口  
	2. RpcClient  
	   负责导入（import）远程接口的代理实现  
	3. RpcProxy  
	   远程接口的代理实现  
	4. RpcInvoker  
	   客户方实现：负责编码调用信息和发送调用请求到服务方并等待调用结果返回  
	   服务方实现：负责调用服务端接口的具体实现并返回调用结果  
	5. RpcProtocol  
	   负责协议编/解码  
	6. RpcConnector  
	   负责维持客户方和服务方的连接通道和发送数据到服务方  
	7. RpcAcceptor  
	   负责接收客户方请求并返回请求结果  
	8. RpcProcessor  
	   负责在服务方控制调用过程，包括管理调用线程池、超时时间等  
	9. RpcChannel  
	   数据传输通道
   
2、Twitter Finagle