####Thinking In Java第四版学习笔记

    一、对象导论
        
        万物皆为对象。
        
        程序是对象的集合，它们通过发送消息来告知彼此所要做的。
        
        每个对象都拥有其类型。
        
        某一特定类型的所有对象都可以接收同样的消息。

    二、一切都是对象 
                
        栈（堆栈）：存放基本类型变量和对象引用变量。位于RAM区
        
        堆：存放new得到的对象和数组。也位于RAM区
        
        常量存储：存放常量，包括静态变量。
        
        1. new出来的对象都是放在堆里的。
        
        2. 基本数据类型（boolean、 byte、char、short、Int、long、float、double、void）存放在栈（堆栈）里。 
        
        3. Java中的数值类型不存在无符号的，它们的取值范围是固定的，不会随着机器硬件环境或者操作系统的改变而改变。
        
        4. BigInteger任意精度整数；BigDecimal任意精度定点数（可用于货币汇率转换）。
        
    三、操作符
     
        1. 赋值表达式是有值的，赋值表达式的值等于要赋的值。
        
        2. 移位操作符：
           
            $<<$：操作数向左移动，低位补0；
            
            $>>$：操作数向右移动，(1)符号为正时，高位补0，(2)符号为负时，高位补1；
            
            $>>>$：java独有操作符，操作数向右移动，高位统一补0。
            
            char，byte，short进行移位操作时先会转成int类型，即32位。
        
        3.三元运算符：
                      
            条件表达式？表达式1：表达式2。
            
            说明：问号前面的位置是判断的条件，判断结果为bool型，为true时调用表达式1，为false时调用表达式2。
        
        4. 将float或double转型为整数值时，总是对数字进行截尾，不会进行四舍五入。如果想要得到舍入的结果可以使用Math.round()。
        
        5. 如果对基本数据类型执行算数运算或按位运算，只要类型比int小（即char、byte或者short），那么在运算之前，这些值会自动转化成int。
        
            这样一来，最终生成的结果就是int类型。如果想把结果赋值给较小的类型，就必须使用类型转化。通常，表达式中出现的最大的数据类型决定了表达式最终结果的数据类型。
            
            如果将一个float值与一个double值相乘，结果就是double，如果将一个int和一个long值相加，则结果为long。
    
    四、控制执行流程
    
        1. returan关键词的用途：指定一个方法返回什么值（假设它没有void返回值），退出当前方法，并返回那个值。
        
        2. break用于强行退出循环，不执行循环中剩余的语句。而continue则停止执行当前的迭代，然后退回到循环起始处，开始下一次迭代。
        
            1）一般的continue会退回到最内层循环的开头，并继续执行。
            
            2）带标签的continue会达到标签的位置，并重新进入紧接在那个标签后面的循环。
            
            3）一般的break会中断并跳出当前循环。
            
            4）带标签的break会中断并跳出标签所指的循环。
            
            使用标签的唯一目的，就是因为循环嵌套的存在。用于多层嵌套的break和continue。
            
        3. switch 语句由一个控制表达式和多个case标签组成。
                 
            1）能用于switch判断的类型有：byte、short、int、char（JDK1.6），还有枚举类型，但是在JDK1.7后添加了对String类型的判断;
            
            2）case语句中少写了break，编译不会报错，但是会一直执行之后所有case条件下的语句而不再判断，一旦case匹配，就会顺序执行后面的程序代码，而不管后面的case是否匹配，直到遇见break或者default语句。
            
            3）若果没有符合条件的case就执行default下的代码块，default并不是必须的，也可以不写.
    
    五、初始化与清理
    
        1. 重载
                
            重载主要以传入参数及顺序来区别。不能通过返回值来区别
            
            以基本数据类型传入时:自动包装机制
            
                1）若传入的数据类型小于方法中声明的形式参数类型，实际数据类型就会提升。
                    
                    byte -> short -> int -> long -> float -> double
                
                2）如果传入的实际参数较大，就得通过类型转换执行窄化转换。
        
        2. this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。
            
             1）表示当前对象的引用；
             
             2）this调用本类中的属性和方法，也就是类中的成员变量和方法；
             
             3）this调用本类中的其他构造方法，调用时要放在构造方法的首行。
        
        3. super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。
        
            1）主要存在于导出类方法中，用于指向导出类对象中父类对象；
            
            2）访问父类的属性；
            
            3）访问父类的函数；
            
            4）问父类的构造函数。
            
        注意：
        
            如果开发者自定义了一个类，没有显示的进行类的继承，那么该类中成员函数是否可以使用super关键字？可以使用，任何类默认继承了Object类，Object类是所有类的父类。
            
            this和super很像，this指向的是当前对象的调用，super指向的是当前调用对象的父类。
            
            类加载完毕，创建对象，父类的构造方法会被调用（默认自动无参），然后执行导出类相应构造创建了一个导出类对象，该导出类对象还包含了一个父类对象。该父类对象在导出类对象内部。
            
            this和super只能在有对象的前提下使用，不能在静态上下文使用。
            
        super和this的异同：
        
            super（参数）：调用基类中的某一个构造函数（应该为构造函数中的第一条语句） 
            
            this（参数）：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句）
            
            super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名    super.成员函数据名（实参）
            
            this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）
            
            调用super()必须写在导出类构造方法的第一行，否则编译不通过。每个导出类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。
            
            super()和this()类似，区别是，super()从导出类中调用父类的构造方法，this()在同一类内调用其它方法。
            
            super()和this()均需放在构造方法内第一行。
            
            尽管可以用this调用一个构造器，但却不能调用两个。
            
            this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。
            
            this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量，static方法，static语句块。
            
            从本质上讲，this是一个指向本对象的指针， 然而super是一个Java关键字。
        
        4. static方法就是没有类中this的方法。
        
            在static方法的内部不能调用非静态方法，反之却可以。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。
            
        5. finalize()工作原理：一旦垃圾回收器准备释放对象占用的存储空间，将先调用其finalize()方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。所以你要是打算使用finalize()，就能在垃圾回收时刻做一些重要的清理工作。
            
            finalize方法，基本只会在java调用了native方法的时候，需要再通过native方法来释放它所占用的内存空间调用。
            
            finalize方法，是发生在jvm进行垃圾回收前调用的方法，所以这个方法所代表的含义就是在jvm垃圾回收前所需要做的有关于内存回收的操作。
            
            还有一种情况是，为了定位bug。
            
            对于finalize()方法的使用，就只有一条建议--------尽量不要使用！！！
            
        6. System.gc()用于强制进行终结动作。作用只是提醒虚拟机：程序员希望进行一次垃圾回收。但是它不能保证垃圾回收一定会进行，而且具体什么时候进行是取决于具体的虚拟机的，不同的虚拟机有不同的对策。
        
            不要使用gc函数，为了保持代码健壮姓（记得将不用的变量置为null），让虚拟机去管理内存。
        
        7. 垃圾回收
           
            1）垃圾收集算法的核心思想  
             
                Java语言建立了垃圾收集机制，用以跟踪正在使用的对象和发现并回收不再使用(引用)的对象。该机制可以有效防范动态内存分配中可能发生的两个危险：因内存垃圾过多而引发的内存耗尽，以及不恰当的内存释放所造成的内存非法引用。  

                垃圾收集算法的核心思想是：对虚拟机可用内存空间，即堆空间中的对象进行识别，如果对象正在被引用，那么称其为存活对象，反之，如果对象不再被引用，则为垃圾对象，可以回收其占据的空间，用于再分配。垃圾收集算法的选择和垃圾收集系统参数的合理调节直接影响着系统性能，因此需要开发人员做比较深入的了解。  
             
            2）触发主GC(Garbage Collector)的条件  
             
                JVM进行次GC的频率很高，但因为这种GC占用时间极短，所以对系统产生的影响不大。更值得关注的是主GC的触发条件，因为它对系统影响很明显。总的来说，有两个条件会触发主GC:  
             
                    ① 当应用程序空闲时，即没有应用线程在运行时，GC会被调用。因为GC在优先级最低的线程中进行，所以当应用忙时，GC线程就不会被调用，但以下条件除外。  
                    
                    ② Java堆内存不足时，GC会被调用。当应用线程在运行，并在运行过程中创建新对象，若这时内存空间不足，JVM就会强制地调用GC线程，以便回收内存用于新的分配。若GC一次之后仍不能满足内存分配的要求，JVM会再进行两次GC作进一步的尝试，若仍无法满足要求，则 JVM将报“out of memory”的错误，Java应用将停止。  

                由于是否进行主GC由JVM根据系统环境决定，而系统环境在不断的变化当中，所以主GC的运行具有不确定性，无法预计它何时必然出现，但可以确定的是对一个长期运行的应用来说，其主GC是反复进行的。  
             
            3）减少GC开销的措施  
             
               　根据上述GC的机制，程序的运行会直接影响系统环境的变化，从而影响GC的触发。若不针对GC的特点进行设计和编码，就会出现内存驻留等一系列负面影响。为了避免这些影响，基本的原则就是尽可能地减少垃圾和减少GC过程中的开销。具体措施包括以下几个方面:  
             
                (1) 不要显式调用System.gc()  
                
                    此函数建议JVM进行主GC，虽然只是建议而非一定，但很多情况下它会触发主GC，从而增加主GC的频率，也即增加了间歇性停顿的次数。  
                
                (2) 尽量减少临时对象的使用  
                
                    临时对象在跳出函数调用后，会成为垃圾，少用临时变量就相当于减少了垃圾的产生，从而延长了出现上述第二个触发条件出现的时间，减少了主GC的机会。  
                
                (3) 对象不用时最好显式置为Null  
                    
                    一般而言，为Null的对象都会被作为垃圾处理，所以将不用的对象显式地设为Null，有利于GC收集器判定垃圾，从而提高了GC的效率。  
                
                (4) 尽量使用StringBuilder，而不用String来累加字符串
                
                    由于String是固定长的字符串对象，累加String对象时，并非在一个String对象中扩增，而是重新创建新的String对象，如 Str5=Str1+Str2+Str3+Str4，这条语句执行过程中会产生多个垃圾对象，因为对次作“+”操作时都必须创建新的String对象，但这些过渡对象对系统来说是没有实际意义的，只会增加更多的垃圾。
                    
                    避免这种情况可以改用StringBuilder来累加字符串，因StringBuilder是可变长的，它在原有基础上进行扩增，不会产生中间对象。  
                
                (5) 能用基本类型如Int，Long，就不用Integer，Long对象  
                
                    基本类型变量占用的内存资源比相应对象占用的少得多，如果没有必要，最好使用基本变量。  
                
                (6) 尽量少用静态对象变量  
                
                    静态变量属于全局变量，不会被GC回收，它们会一直占用内存。  
                
                (7) 分散对象创建或删除的时间  
                
                    集中在短时间内大量创建新对象，特别是大对象，会导致突然需要大量内存，JVM在面临这种情况时，只能进行主GC，以回收内存或整合内存碎片， 从而增加主GC的频率。集中删除对象，道理也是一样的。它使得突然出现了大量的垃圾对象，空闲空间必然减少，从而大大增加了下一次创建新对象时强制主GC 的机会。

        8. 初始化顺序
           
            所有的变量都会在任何方法（包括构造器）被调用之前得到初始化。
            
            无论创建多少对象，静态数据都只占用一份存储区域，static不能作用于局部变量。且静态初始化动作只执行一次。
            
            成员初始化。初始化的顺序是，先静态对象，而后是“非静态对象”。对于方法的局部变量，如果没有初始化编译时会报未初始化的错。
           
            构造器初始化。可以使用构造器进行初始化，但是自动初始化将会在构造器被调用之前发生，给成员变量赋默认初始“零值”。
            
            静态数据的初始化。无论创建多少个对象，静态数据都只占用一份存储区域。static关键字不能应用于局部变量，因此它只能作用于域。如果一个域是静态的基本类型域，且也没有对它进行初始化。那么它会获得基本类型的标准初值。
            
            如果它是一个对象引用，那么它的默认初始值就是null。静态初始化动作只进行一次：当首次生成这个类的一个对象时，或者首次访问属于这个类的静态成员时（即便从未生成过那个类的对象）。
            
            数组初始化。数组只是相同类型的、用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。拥有的只是对数组的一个引用。数组的创建是在运行时刻进行的。可变参数列表。提供了一种方便的语法来创建对象并调用方法。由于所以的类都直接或间接继承于Object类，所以可以创建以Object数组为参数的方法。
            
            枚举类型。当创建枚举时，编译器会自动添加一些有用的特性，比如toString()方法，显示某个enum实例的名字。ordinal()方法，用来表示某个特定enum常量的声明顺序。static values()，用来按照enum常量的声明顺序，产生由这些常量值构成的数组。

        9. 可变参数列表
        
            定义：void method(Object... args){}
            
            调用：method()或method(new Object[]{1, 2, 3, 4});
    
    六、访问权限控制
    
        public的类、类属变量及方法，包内及包外的任何类均可以访问；
        
        protected的类、类属变量及方法，包内的任何类，及包外的那些继承了此类的导出类才能访问；
        
        private的类、类属变量及方法，类自己的内部类可以访问，其他任何类均不能访问；
        
        如果一个类、类属变量及方法不以这三种修饰符来修饰，它就是friendly类型的，那么包内的任何类都可以访问它，而包外的任何类都不能访问它(包括包外继承了此类的导出类)，因此，这种类、类属变量及方法对包内的其他类是友好的，开放的，而对包外的其他类是关闭的。

    七、复合类
    
        1. 导出类实例化的时候会默认调用父类的无参构造函数。
        
        2. 确保正确清理。许多情况下，清理并不是问题，仅需让垃圾回收器完成该动作就行。但当必须亲自处理清理时，就要多加小心。因为，垃圾回收器可能永远也无法被调用，即时被调用，它是按照任何它想要的顺序来回收对象。最好的办法是除了内存以外，不能依赖垃圾回收器去做任何事。如果需要清理，就自己写一个清理方法，但不要使用finalize()。
        
        3. 当你选择覆写某个方法时，可以选择添加这个@Override注解。
           
        4. 在组合与继承之间选择。组合和继承都允许在新的类中放置导出对象，组合是显式地这样做，而继承是隐式地做。一般来说很简单。如果是“is-a”的关系，那就使用继承。如果是“has-a”的关系，那就使用组合。
        
        6. protected关键字。在实际项目中，经常会想要将某些事物尽可能对这个世界隐藏起来，但仍允许导出类的成员访问它们。这时候便可以使用protected关键字。
           
        7. 向上转型。导出类引用向上转型成为基类引用。因为导出类一定具有基类的方法。所以这种转型是肯定可以的。类接口唯一可能发生的事情是丢失方法，而不是获取它们。
        
        8. final。意味着不可修改！
        
            1）final数据。
            
                1、一个永远不变的编译时常量。
                 
                2、一个在运行时被初始化的值，但不会再被改变。这是针对于基本数据类型。如果当final修饰一个引用的时候，那是意味着这个引用永远不能再改变了，不能再指向其他对象，但是对象的内容是可以改变的。
                
                注意： 一个既是static又是final的字段只占据一段不能修改的存储空间。
            
            2）空白final。所谓空白final指被声明为final但又未给定初值的字段。但编译器必须确保空白final在使用前必须被初始化。所以必须在字段的定义处或者每个构造器中用表达式对final进行赋值。
            
            3）final参数。Java允许在参数列表中以声明的方式将参数指明为final。这意味着你无法在方法中更改参数引用所指向的对象。
            
            4）final方法。使用final方法有两个原因。
            
                1、把方法锁定，以防任何继承类修改它的含义。可以确保在继承中使方法行为保持不变，并且不会被覆盖。
                
                2、使用final限定方法时。等于同意编译器将针对这个方法的所有调用转为内嵌调用。但现在一般只有要明确禁止覆盖时，才将方法设置为final。
            
            5）final和private关键字。类中的所有private方法都隐式地指定为是final。由于无法取用private方法，所以也就无法覆盖它。对private方法添加final修饰词是没有什么意义的。
            
            6）final类。当将某个类的整体定义为final时（通过关键字final置于它的定义之前），就表明了你不打算继承该类，并且也不允许别人这么做。
        
        9. 初始化及类的加载。
        
            Java中的所有事物都是对象。所以它采用了不同的加载方式。每个类的编译代码都在它自己的独立的文件之中，该文件只有需要使用程序代码时才会被加载。“类的代码在初次使用时才加载”。
        
            这通常是指加载发生在创建类的第一个对象之时，但是当访问static域或static方法时，也发生加载。初次使用之处也是static初始化发生之处。
            
            所有的static对象和static代码段都会在加载时依程序中的顺序（即，类定义时的书写顺序）而依次初始化并且只会被初始化一次。
            
            其实构造器也是static方法，尽管static关键字并没有显式地写出来。因此更准确地讲，类是在其任何static成员被访问时加载的。
           
            运行一个类时的加载顺序是这样的：
            
                假设该类名为Bettle。首先访问Beetle.main()（一个static方法），于是加载器开始启动并找出Beetle类的编译代码（在名为Beetle.class的文件之中）。
           
            在对它进行加载的过程中，编译器注意到它有一个基类（这是由关键字extends得知的），于是它继续进行加载。不管你是否打算产生一个该基类的对象，这都要发生。如果该基类还有其自身的基类，那么第二个基类就会被加载，如此类推。
            
            接下来，根基类中的static初始化即会被执行，然后是下一个导出类，以此类推。这种方式很重要，因为导出类的static初始化可能会依赖于基类成员能否被正确初始化。至此，必要的类都有已经加载完毕。于是就可以开始创建对象。
            
            首先，对象中所有的基本类型都会被设为默认值“零值”，对象引用被设为null--这是通过将对象的内存设为二进制零值而一举产生的。然后，基类的构造器会被调用。在本例中，它是被自动调用的。但也可以用super来指定对基类构造器的调用。
            
            基类构造器和导出类的构造器一样，以相同的顺序来经历相同的过程。在基类构造器完成之后，实例变量按其次序被初始化。最后，构造器的其余部分被执行。

    八、多态
        
        1. 多态通过分离做什么和怎么做，从另一角度将接口和实现分离开来。多态不但能够改善代码的组织结构和可读性，还能够创建可扩展的程序。
        
        2. “封装”通过合并特征和行为来创建新的数据类型。“实现隐藏”则通过将细节“私有化”把接口和实现分离开来。多态的作用则是消除类型之间和耦合关系。
        
            继承允许将对象视为它自己本身的类型或其基类型来处理。这种能力极为重要，因为它允许将多种类型（从同一基类导出的）视为同一类型来处理。
            
            而同一份代码也就可以毫无差别地运行在这些不同类型之上了。多态方法调用允许一种类型表现出与其他相似类型之间的区别，只要它们都是从同一基类导出来的。
            
            这种区别是根据方法行为的不同而表示出来的，虽然这些方法都可以通过同一个基类来调用。
            
        3. 再论向上转型。把对某个对象的引用视为对其基类型的引用的做法称为向上转型--因为在继承树的画法中，基类是放置在上方的。为什么我们要向上转型成基类引用呢？主要还是为了复用代码。
        
        4. 方法调用绑定。将一个方法调用同一个方法主体关联起来被称作绑定。若在程序执行前进行绑定（如果有的话，由编译器和连接程序实现），叫做前期绑定。
        
            但如果传入的参数一开始编译的时候只有基类的引用，编译器并不知道该去调用哪个方法。所以，解决的办法就是后期绑定。后期绑定的含义就是在运行时根据对象的类型进行绑定。
            
            后期绑定也叫做动态绑定或运行时绑定。如果一种语言想实现后期绑定，就必须具有某种机制，以便在运行时能判断对象的类型，从而调用恰当的方法。
            
            也就是说，编译器一直不知道对象的类型，但方法调用机制能找到正确的方法体，并加以调用。后期绑定机制随编程语言的不同而有所不同，但是只要想一下就会得知，不管怎样都必须在对象中安置某种“类型信息”。
            
            Java中除了static方法和final方法（private方法属于final方法）之外，其他所有的方法都是后期绑定。将方法声明为final后，可以防止其他人覆盖该方法。也可以有效地“关闭”动态绑定。
        
        5. 产生正确的行为。一旦知道Java中所有方法都是通过动态绑定实现多态之后，我们就可以编写只与基类打交道的代码了，并且这些代码对所有的导出类都可以正确运行。或者换一种说法，发送消息给某个对象，让该对象去断定应该做什么事。
           
        6. 可扩展性。由于有多态机制。我们就可以根据自己的需求对系统添任意多的新类型。而不需增加或更改go()方法。大多数或者所有方法都会遵守go()的模型，而且只与基类接口通信。
        
            这样的程序是可扩展的，因为可以从通用的基类继承出新的数据类型，从而新添一些功能。那些操纵基类接口的方法不需要任何改动就可以应用于新类。
        
        7. 缺陷：“覆盖”私有方法。
            
            由于private方法是自动认为是final方法，而且对导出类是屏蔽的。因此，这种情况下。Derived类中的f()方法就是一个全新的方法，基类中的f()方法在导出类Derived中不可见，因此也不能被重载。只有非private方法才可以被覆盖。在导出类中，对于基类中的private方法，最好采用不同的名字。
        
        8. 缺陷：域与静态方法。只有普通的方法是多态的。而且当一个方法是静态的，它的行为也就不具有多态性。静态方法是与类，而并非与单个对象相关联的。
        
        9. 构造器和多态。首先，构造器并不具有多态性。（它们实际上是static方法，只不过该static声明是隐式的）。
                                
            初始化的过程：
                
                1）在所有事物发生之前，将分配给对象的存储空间初始化为二进制的零。
                
                2）调用基类构造器。
                
                3）按照声明顺序调用成员的初始化方法。
                
                4）调用导出类（本体）的构造器主体。
        
        10. 继承与清理。通过组合和继承来创建新类时，永远不必担心对象的清理问题。子对象通常都会留给垃圾回收器进行处理。如果确实遇到问题，那么必须用心为新类创建dispose()方法。
        
            并且由于是继承的缘故，如果我们有其他作为垃圾回收一部分的特殊清理动作，就必须在导出类中覆盖dispose()方法。当覆盖被继承类的dispose()方法时，务必记住调用基类的super.dispose()方法。否则，基类的清理动作就不会发生。    
            
            注意，尽管通常不必执行清理工作，但是一旦选择执行就必须谨慎和小心！
            
        11. 协变返回类型。Java SE5中添加了协变返回类型，它表示在导出类的被覆盖方法可以返回基类方法的返回类型的某种导出类型。
        
        12. 用继承进行设计。当在使用现成的类来建立新类时，首先应当还是考虑“组合”。组合不会强制我们的程序设计进入继承的层次结构中，而且，组合更加灵活，因为它可以动态选择类型。
        
            相反，继承在编译时就需要知道确切类型。比如我new 一个Car 。我可以在程序运行过程中让它从奔驰变为宝马，也可以变成奥迪（这个也称为状态模式）。但是继承，我一旦new了，奔驰就是奔驰，并不能再变成宝马。我们不能在运行期间决定继承不同的对象。
            
            1）纯继承与扩展。纯继承：只有在基类中已经建立的方法才可以在导出类中覆盖。就是“is-a”的关系。因为一个类的接口已经确定了它应该是什么。继承可以确保所有的导出类具有基类的接口，且绝对不会少。
            
                这就是一种纯替代。因为导出类可以完全替代基类，使用时，完全不需要知道关于子类的任何额外信息。扩展：就是“is-like-a”的关系。因为导出类就像是一个基类--具有相同的基本接口，但是它还具有由额外方法实现的其他特性。
                
                虽然这是一种有用的方法，但还是要依赖于具体的情况。它的缺点是，导出类中接口的扩展部分不能被基类访问。因此一旦向上转型，就不能调用那些新方法。
            
            2）、向下转型与运行时类型识别。在Java中，所有转型都会得到检查。这些都是在运行期间对类型进行检查的行为。一般来说，如果你知道这个对象的具体类型，就可以尝试向下转型。如果所转类型是正确的，那么转型成功。如果是错误的，便会返回一个ClassCastException异常。
    
    九、接口
    
        1. 抽象类和抽象方法。
        
            包含抽象方法的类叫做抽象类。如果一个类包含一个或多个抽象方法，该类必须被限定为抽象的。（否则，编译器便会报错。）
        
            如果从一个抽象类继承，并想创建该新类的对象。那么就必须为基类中的所有抽象方法提供方法定义。如果不这样做，那么导出类便也是抽象类，且编译器将会强制我们用abstract关键字来限定这个类。
            
            创建抽象类和抽象方法非常有用，因为它们可以使类的抽象性明确起来，并告诉用户和编译器打算怎样来使用它们。抽象类还是很有用的重构工具，因为它们使得我们可以很容易地将公共方法沿着继承层级结构向上移动。
            
        2. 接口。
        
            interface关键字使抽象的概念更向前迈进了一步。abstract关键字允许人们在类中创建一个或多个没有任何定义的方法---提供了接口部分，但是没有提供任何相应的具体实现。这些实现是由此类的继承者创建的。interface这个关键字产生一个完全抽象的类，它根本就没有提供任何具体实现。
           
            可以选择在接口中显式地将方法声明为public的，但即使不这么做， 它们也是public的。因此，当要实现一个接口时，在接口中被定义的方法必须被定义为是public的。否则，它们将只能得到默认的包访问权限，这样在方法被继承的过程中，其可访问权限就被降低了，这是java编译器所不允许的。
           
            在接口中的每一个方法确实都是一个声明，这是编译器所允许的在接口中唯一存在的事物。
        
        3. 完全解偶。
        
            只要一个方法操作的是类而非接口。那么你就只能使用这个类及其子类。如果你想要将这个方法应用于不在此继承结构中的某个类，那么就不行了。接口可以在很大程度上放宽这种限制。因此，它可以使得我们编写复用性更好的代码。
            
            策略设计模式：创建一个能够根据所传递的参数对象的不同而具有不同行为的方法。这类方法包含所要执行的算法中固定不变的部分。而“策略”包含变化的部分。策略就是传递进去的参数对象，它包含要执行的代码。
            
            适配器设计模式：适配器中的代码将接受你所拥有的接口，并产生你所需要的接口。 
        
        4、Java中的多重继承。
        
            就是实现多个接口。这也是使用接口的核心原因，为了能够向上转型为多个基类型（以及由此带来的灵活性）。然后，使用接口的第二个原因却是与使用抽象基类相同：防止客户端程序员创建该类的对象，并确保这仅仅是建立一个接口。
         
            但这就带来一个问题，我们应该使用接口还是抽象类？如果要创建不带任何方法和成员变量的基类，那么就应该选择接口而不是抽象类。
        
        5. 通过继承来扩展接口。
        
            通过继承，可以很容易地在接口中添加新的方法声明，还可以通过继承在新接口中组合数个接口。
           
            组合接口时的名字冲突：可以重载方法，覆写方法写个@Override注解。尽量还是避免在不同的接口中使用相同的方法名造成代码可读性的混乱。    
        
        6. 接口中的域。
        
            放入接口中的任何域（字段）都自动是static和final的，同时也是自动public的。
            
            在接口中定义的域不能是“空final”的，但是可以被非常量表达式初始化。
            
            既然域是static的，它们就可以在类第一次被加载时初始化，这发生在任何域首次被访问时。当然，这些域不是接口的一部分，它们的值被存储在该接口的静态存储区域内。
            
        7. 接口嵌套。
         
            接口可以嵌套在类或其他接口中。
            
        8. 接口与工厂。
        
            工厂方法设计模式非常好用，复用代码很方便，与直接调用构造器不同，我们在工厂对象上调用的是创建方法。该工厂对象将生成接口的某个实现的对象。
    
    十、内部类
    
        1. 将一个类的定义放在另一个类的定义内部，这就是内部类。内部类是一种非常有用的特性，因为它允许你把一些逻辑相关的类组织在一起，并控制位于内部的类的可视性。
        
        2. 如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须像在main()方法中那样，具体地指明这个对象的类型：OuterClassName.InnerClassName。
        
            内部类拥有其外围类的所有元素的访问权。意思是通过内部类能够获得其外部类的内存信息（参数值）。故不能直接通过创建普通对象的方法创建内部类，必须要通过外部类才能创建。
        
        3. 链接到外部类。
           
            当生成一个内部类的对象时，此对象与制造它的外围对象之间就有了以一种联系。所以它能访问其外围对象的所有成员，而不需要任何特殊条件。此外，内部类还拥有其外围类的所有元素的访问权。
           
            这是如何做到的呢？当某个外围类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用。然后，在你访问此外围类的成员时，就是那个引用来选择外围类的成员。
        
        4. .new语法：可以直接创建其内部类，但前提也是要提供其外部类的引用（OuterClassObject.new InnerClassName()）。
            
            在拥有外部类对象之前是不可能创建内部类对象的。这是因为内部类对象会暗暗地连接到创建它的外部类对象上。但是，如果你创建的是嵌套类（静态内部类），那么它就不需要对外部类对象的引用。
            
        5. 内部类与向上转型。
        
            当将内部类向上转型为其基类，尤其是转型为一个接口的时候，内部类就有了用武之地。
            
            （从实现了某个接口的对象，得到对此接口的引用，与向上转型为这个对象的基类，实质上效果是一样的）这是因为此内部类---某个接口的实现---能够完全不可见，并且不可用。
            
            所得到的只是指向基类或接口的引用，所以能够很方便地隐藏实现细节。
        
        6. 在方法和作用域内的内部类。
        
            可以在一个方法里面或在任意的作用域内定义内部类。这么做有两个理由：
            
                1）如果实现了某类型的接口，于是可以创建并返回对其的引用。
                
                2）你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但是又不希望这个类是公共可用的。
            
            内部类可以嵌入在任何堆作用域内，但只在其作用域内可用。称作为局部内部类。
            
        7. 匿名内部类。
        
            匿名内部类是一个没有名字的内部类，通常使用它来简化代码编写，同时必须继承一个父类或实现一个接口。
            
            常用的扩展是将只使用一次的工厂类作为匿名内部类放在生产类上。
            
            如果定义一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器会要求其参数是final的。否则，编译器将会报错。如果只是传递给匿名类的基类的构造器，那么不需要将传入的形参定为final。
        
        8. 嵌套类。
        
            如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为static。这通常被称为嵌套类。
            
            想要理解static应用于内部类时的含义，就必须记住，普通的内部类对象隐式地保存了一个引用，指向创建它的外围类对象。然而，当内部类是static的时，就不是这样了。
            
            嵌套类意味着：
           
                1）要创建嵌套类的对象，并不需要其外围类的对象。
           
                2）不能从嵌套类的对象中访问非静态的外围类对象。
           
            嵌套类与普通的内部类还有一个区别，普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有static数据和static字段，也不能包含嵌套类。但是嵌套类可以包含所有这些东西。
           
            接口内部的类：正常情况下，不能在接口内部放置任何代码。但嵌套类可以作为接口的一部分。你放到接口中的任何类都自动是public和static的。因为类是static的，只是将嵌套类置于接口的命名空间内，这并不违反接口的规则。
            
            从多层嵌套类中访问外部类的成员：一个内部类被嵌套多少层并不重要--它能透明地访问所以它所嵌入的外围类的所有成员。
    
        9. 为什么需要内部类。
        
            一般来说，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外围类的对象。所以可以认为内部类提供了某种进入其外围类的窗口。
            
            每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。
            
            内部类允许继承多个非接口类型（类或抽象类）。
            
            内部类的特性：
            
                1）内部类可以有多个实例，每个实例都有自己的状态信息。并且与其外围类对象的信息相互独立。
                
                2）在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。
                
                3）创建内部类对象的时刻并不依赖于外围类对象的创建。
                
                4）内部类并没有令人迷惑的“is-a”关系；它就是一个独立的实体。
            
            闭包与回调：闭包是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。
            
            通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外围类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括private成员。
        
        10. 内部类的继承。
        
            因为内部类的构造器必须连接到指向其外围类对象的引用，所以在继承内部类的时候，事情会变得有点复杂。
            
            问题在于，那个指向外围类的“秘密的”引用必须被初始化，而在导出类中不再存在可连接的默认对象。
            
            要解决这个问题，必须使用特殊的语法来明确说清它们之间的关联：
            
                必须在构造器内使用如下语法：enclosingClassReference.super(); 这样才提供了必要的引用，然后程序才能编译通过。
        
        11. 内部类可以被覆盖吗？
        
            默认的构造器是编译器自动生成的，这里是调用基类的默认构造器。你可能认为既然创建了BigEgg的对象，那么所使用的应该是“覆盖后”的Yolk版本。
            
            但实际情况并不是这样。当继承了某个外围类的时候，内部类并没有发生什么特别神奇的变化。这两个内部类完全是独立的两个实体。各自在自己的命名空间内。当然，明确地继承某个内部类也是可以的。
        
        12. 局部内部类。
        
            可以在代码块中创建内部类。典型的方式是在一个方法体的里面创建。局部内部类不能有访问说明符，因为它不是外围类的一部分。但是它可以访问当前代码块内的常量以及此外围类的所有成员。
            
        13、内部类标识符。
        
            由于每个类都会产生一个.class文件，其中包含了如何创建该类型的对象的全部信息。（此信息产生一个“meta-class”，叫做Class对象）。
            
            内部类也必须生成一个.class文件以包含它们的Class对象信息。这些类文件的命名有严格的规则：外围类的名字，加上"$"，再加上内部类的名字。
            
            如果内部类是匿名的，编译器会简单地产生一个数字作为标识符。如果内部类是嵌套在别的内部类之中，只需直接将它们的名字加载其外围类标识符与“$”的后面。
    
    十一、持有对象
    
        1. 各种容器。
        
            ArrayList LinkedList 都是按插入顺序存放数据；
            
            ArrayList在随机访问速度上比较快，而LinkedList在插入和删除数据比较有优势，具有Queue，Stack的特性；
            
            HashSet TreeSet LinkedHashSet；
            
            HashMap TreeMap LinkedHashMap；
            
            通用点：Hash开头的容器都是通过Hash值来查找数据，所以特点是无序但速度快；
            
            Tree开头的容器都会将存入的数据进行升序排列；
            
            Linked则是按插入的顺序进行排序。  
        
        2. 迭代器
        
            具有以下特性：
                
                1）创建代价小，单向移动；
                
                2）使用方法iterator()要求容器返回一个Iterator。Iterator将准备好返回序列的第一个元素；
                
                3）使用next()获取序列中的下一个元素；
                
                4）使用hasNext()检查序列中是否还有元素；
                
                5）使用remove()移除由next()返回的元素。
           
            ListIterator 作为List特有的迭代器，具有双向移动功能，其对应方法为hasPrevious()，previous()，使用add()添加元素，set()修改最后一个访问的元素。
            
        3. 栈
           
           后进先出，通常可以使用LinkedList来实现Stack的功能。
           
        4. 队列
           
           先进先出，同样可以使用LinkedList来实现功能，由于其实现了Queue接口，可以将其向上转型。
        
        5. 优先队列
           
           PriorityQueue：简单来说就是具有排序功能的队列，下一个弹出的元素是在队列中优先级最高的一个。使用Comparator比较器来进行比较。
        
        6. foreach语法用于任何实现了Iterable接口的类。Collection接口扩展了Iterable接口，所以所有Collection对象都适用foreach语法。实现Collection就意味着需要提供iterator()方法。
        
    十二、通过异常处理错误
    
        1. 异常使用指南
        
            1）在恰当的级别处理问题（只在知道如何处理异常的时候才捕获异常）。
            
            2）解决问题并且重新调用产生异常的方法。
            
            3）进行少许修补，然后绕过异常发生的地方继续执行。
            
            4）用别的数据进行计算，以代替异方法预计会返回的值。
            
            5）把当前运行环境下能做的事情尽量做完，然后将相同的异常重抛到更高层。
            
            6）把当前运行环境下能做的事情尽量做完，然后将不同的异常重抛到更高层。
            
            7）终止程序。
            
            8）进行简化。
            
            9）让类库和程序更安全。
   
    十三、字符串
    
        1. String对象是不可变的。String类中每个看起来会修改String值的方法，实际上都是创建了一个全新的String对象，以包含修改后的字符串内容。而最初的String对象则丝毫未动。
        
        2. 用于String的“+”与“+=”是Java中仅有的两个重载过的运算符，Java不允许程序员重载任何运算符。
        
        3. String的不可变性带来了一定的效率问题，比如String的“+”运算，每“+”一次都会生成一个新的String对象。Java编译器一般会自动优化，但不同情况下，优化的程度不够。
        
        4. StringBuffer的内部实现方式和String不同，StringBuffer在进行字符串处理时，不生成新的对象，在内存使用上要优于String类。所以在实际使用时，如果经常需要对一个字符串进行修改，例如插入、删除等操作，使用StringBuffer要更加适合一些。
        
        5. 无意识的递归
        
            由String对象后面跟着一个“+”，再后面的对象不是String时，编译器会使后面的对象通过toString()自动类型转换成String，如果这发生在自定义的类的重写的toString()方法体内，就有可能发生无限递归，运行时抛出java.lang.StackOverflowError栈溢出异常。
            
            public class InfiniteRecursion{
                public String toString(){
                    //应该调用Object.toString()方法，所以此处应为super.toString()。
                    return " InfiniteRecursion address: " + this + "\n"; 
                }
                public static void main(String[] args){
                    List<InfiniteRecursion> v = new ArrayList<InfiniteRecursion>();
                    for(int i = 0; i < 10; i++)
                        v.add(new InfiniteRecursion());
                    System.out.println(v);
                }
            }
    
        6. String.format()方法用于创建格式化的字符串以及连接多个字符串对象。
        
        7. 正则表达式
        
            ？？？
        
        8. 扫描输入
        
            ？？？
        
        9. StringTokenizer
        
            Java中substring方法可以分解字符串，返回的是原字符串的一个子字符串。如果要将一个字符串分解为一个一个的单词或者标记，StringTokenizer可以帮你。
    
    十四、类型信息
    
        1. RTTI（Runtime Type Identification）运行阶段类型识别
            
            在Java中，所有的类型转换都是在运行时进行正确性检查的。这也是RTTI的含义：在运行时，识别一个对象的类型。
            
            
                1）多态中表现的类型转换是RTTI最基本的使用形式，但这种转换并不彻底。如数组容器实际上将所有元素当作Object持有，取用时再自动将结果转型回声明类型。
                
                    而数组在填充（持有）对象时，具体类型可能是声明类型的子类，这样放到数组里就会向上转型为声明类型，持有的对象就丢失了具体类型。而取用时将由Object只转型回声明类型，并不是具体的子类类型，所以这种转型并不彻底。
            
                2）多态中表现了具体类型的行为，但那只是“多态机制”的事情，是由引用所指向的具体对象而决定的，并不等价于在运行时识别具体类型。
            
            以上揭示了一个问题就是具体类型信息的丢失！有了问题，就要解决问题，这就是RTTI的需要，即在运行时确定对象的具体类型。

            package net.mrliuli.rtti;
            
            import java.util.Arrays;
            import java.util.List;
            
            /**
             * Created by leon on 2017/12/3.
             */
            
            abstract class Shape{
                void draw(){
                    System.out.println(this + ".draw()");
                }
                abstract public String toString();  //要求子类需要实现 toString()
            }
            
            class Circle extends Shape{
                @Override
                public String toString() {
                    return "Circle";
                }
                public void drawCircle(){}
            }
            
            class Square extends Shape{
                @Override
                public String toString() {
                    return "Square";
                }
            }
            
            class Triangle extends Shape{
                @Override
                public String toString() {
                    return "Triangle";
                }
            }
            
            public class Shapes {
                public static  void main(String[] args){
                    List<Shape> shapeList = Arrays.asList(
                            new Circle(), new Square(), new Triangle()  // 向上转型为 Shape，此处会丢失原来的具体类型信息！！对于数组而言，它们只是Shape类对象！
                    );
                    for(Shape shape : shapeList){
                        shape.draw();   // 数组实际上将所有事物都当作Object持有，在取用时会自动将结果转型回声明类型即Shape。
                    }
                    //shapeList.get(0).drawCircle(); //这里会编译错误：在Shape类中找不到符号drawCircle()，证实了具体类型信息的丢失!!
                }
            }
            
        2. RTTI在Java中的工作原理
           
            要能够在运行时识别具体类型，说明必然有东西在运行时保存了具体类型信息，这个东西就是Class对象，一种特殊对象。即Class对象表示了运行时的类型信息，它包含了与类有关的信息。
           
                1）事实上Class对象就是用来创建类的所有的“常规”对象的。
               
                2）每个类都有一个Class对象。换言之，每当编写并且编译了一个新类，就会产生一个Class对象（更恰当地说，是被保存在一个同名的.class文件中）。
               
            也就是说，Class对象在.java文件编译成.class文件时就生成了，且就保存在这个.class文件中。

        3. Class对象用来生成对象（常规对象，非Class对象）
           
            运行程序的JVM使用所谓的“类加载器”的子系统（class loader subsystem）通过加载Class对象（或者说.class文件）来生成一个类的对象。
           
                1）所有的类都是在对其第一次使用时，动态加载到JVM中的。当程序第一次使用类的静态成员时，就会加载这个类，这说明构造器也是静态方法，即使构造器前面没加static关键字。
               
                2）因此，Java程序在它开始运行之前并非被完全加载，其各个部分是在必须时才被加载的。（C++这种静态加载语言是很难做到的。）
        4. 类加载器的工作（过程）
           
            1）首先检查一个类的Class对象（或理解.class文件）是否已被加载；
            
            2）如果尚未加载，默认的类加载器就会根据类名查找.class文件；
            
            3）一旦Class对象（.class文件）被加载了（载入内存），它就被用来创建这个类的所有对象。
            
            说明：
            
                Class对象仅在需要时才被加载，static初始化是在类加载时进行的。
                
                Class.forName(net.mrliuli.rtti.Gum)是Class类的一个静态成员，用来返回一个Class对象的引用（Class对象和其他对象一样，我们可以获取并操作它的引用（这也就是类加载器的工作））。
                
                使用这个方法时，如果net.mrliuli.rtti.Gum还没有被加载就加载它。在加载过程中，Gum的static子句被执行。
                
                总之，无论何时，只要你想在运行时使用类型信息，就必须首先获得对恰当的Class对象的引用。 

        5. 获得Class对象引用的方法
           
            Class.forName()方法的作用，就是初始化给定的类。
            
            通过Class.forName()，就是一个便捷途径，这种方式不需要为了获得Class对象引用而持有该类型的对象。（即没有创建过或没有这个类型的对象的时候就可以获得Class对象引用。）
            
            如果已经有一个类型的对象，那就可以通过调用这个对象的getClass()方法来获取它的Class对象引用了。这个方法属于Object，返回表示该对象的实际类型的Class对象引用。
        
        6. Class包含的很多有用的方法:
           
            getName() 获取类的全限定名称
            getSimpleName() 获取不含包名的类名
            getCanonicalName() 获取全限定的类名
            isInterface() 判断某个Class对象是否是接口
            getInterfaces() 返回Class对象实现的接口数组
            getSuperClass() 返回Class对象的直接基类
            newInstance() 创建一个这个Class对象所代表的类的一个实例对象
            
            1）Class引用在编译期不具备任何更进一步的类型信息，所以它返回的只是一个Object引用，但是这个Object引用指向的是这个Class引用所代表的具体类型。即需要转型到具体类型才能给它发送Object以外的消息
            
            2）newInstance()这个方法依赖于Class对象所代表的类必须具有可访问的默认的构造函数（Nullary constructor，即无参的构造器），否则会抛出InstantiationException 或 IllegalAccessException 异常

        7. 使用类字面常量.class是获取Class对象引用的另一种方法。如 FancyToy.class。建议使用这种方法。
                       
            编译时就会受到检查（因此不需要放到try语句块中），所以既简单又安全。根除了对forName()的调用，所以也更高效。
            
            类字面常量.class不仅适用于普通的类，也适用于接口、数组和基本类型。
            
            基本类型的包装器类有一个标准字段TYPE，它是一个引用，指向对应的基本数据类型的Class引用，即有boolean.class 等价于 Boolean.TYPE，int.class 等价于 Integer.TYPE…
            
            注意：
            
                使用.class来创建Class对象的引用时，不会自动地初始化该Class对象。但是为了产生Class引用，Class.forName()就立即进行了初始化操作。
            
                如果字段用static final来修饰，就是编译器常量，那么这个值不需要对该类进行初始化就能被读取。
            
                getClass()是Object的方法，返回class对象。
                
                forName()是Class类的方法，返回class对象。
                
                类字面常量是通过：XXX.class返回class对象。
        
        8. 为了使用类而做的准备工作实际包含三个步骤：
                       
            1）加载。这是由类加载器执行的。该步骤将查找字节码（通常在CLASSPATH所指定的路径中查找.class文件，但这并不是必须的），并从这些字节码中创建一个Class对象。
            
            2）链接。在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果必需的话，将解析这个类创建的对其他类的所有引用。
            
            3）初始化。如果该类具有超类，则对其初始化，执行静态初始化器和静态初始块。
                
                初始化被延迟到了对静态方法（构造器隐式地是静态的）或者非常数静态域进行首次引用时才执行，即初始化有效地实现了尽可能 的“惰性”。 
                        
            package net.mrliuli.rtti;
            
            import java.util.Random;
            
            class Initable{
                static final int staticFinal = 47;      // 常数静态域
                static final int staticFinal2 = ClassInitialization.rand.nextInt(1000);     // 非常数静态域（不是编译期常量）
                static{
                    System.out.println("Initializing Initable");
                }
            }
            
            class Initable2{
                static int staticNonFinal = 147;    // 非常数静态域
                static {
                    System.out.println("Initializing Initable2");
                }
            }
            
            class Initable3{
                static int staticNonFinal = 74;     // 非常数静态域
                static {
                    System.out.println("Initializing Initable3");
                }
            }
            
            public class ClassInitialization {
            
                public static Random rand = new Random(47);
                
                public static void main(String[] args) throws Exception {
                    Class initalbe = Initable.class;                // 使用类字面常量.class获取Class对象引用，不会初始化
                    System.out.println("After creating Initable ref");
                    System.out.println(Initable.staticFinal);       // 常数静态域首次引用，不会执行初始化就可以读取
                    System.out.println(Initable.staticFinal2);      // 非常数静态域首次引用，会初始化
                    System.out.println(Initable2.staticNonFinal);   // 非常数静态域首次引用，会初始化
                    Class initable3 = Class.forName("net.mrliuli.rtti.Initable3");      // 使用Class.forName()获取Class对象引用，会初始化
                    System.out.println("After creating Initable3 ref");
                    System.out.println(Initable3.staticNonFinal);   // 已初始化过
                }
            
            }
        
        9. Class.forName()与ClassLoader.loadClass(className)的区别
                    
            装载：通过累的全限定名获取二进制字节流，将二进制字节流转换成方法区中的运行时数据结构，在内存中生成Java.lang.class对象； 
            
            链接：执行下面的校验、准备和解析步骤，其中解析步骤是可以选择的； 
            
            　　校验：检查导入类或接口的二进制数据的正确性；（文件格式验证，元数据验证，字节码验证，符号引用验证） 
            
            　　准备：给类的静态变量分配并初始化存储空间； 
            
            　　解析：将常量池中的符号引用转成直接引用； 
            
            初始化：激活类的静态变量的初始化Java代码和静态Java代码块，并初始化程序员设置的变量值。
            
            Class.forName(className)方法，内部实际调用的方法是  Class.forName(className,true,classloader);
            
                第2个boolean参数表示类是否需要初始化，  Class.forName(className)默认是需要初始化。
                
                一旦初始化，就会触发目标对象的 static块代码执行，static参数也也会被再次初始化。

            ClassLoader.loadClass(className)方法，内部实际调用的方法是  ClassLoader.loadClass(className,false);
            
                第2个 boolean参数，表示目标对象是否进行链接，false表示不进行链接。不进行链接意味着不进行包括初始化等一些列步骤，那么静态块和静态对象就不会得到执行。
        
        10. 泛化的Class引用
        
            Class引用总是指向某个Class对象，它可以制造类的实例，并包含可作用于这些实例的所有方法代码。它还包含该类的所有静态成员，因此，Class引用表示的就是它所指向的对象的确切类型，而该对象便是Class类的一个对象。
            
                Class intClass = int.class;
                //通过泛型语法，可让编译器强制执行额外的类型检查
                Class<Integer> genericIntClass = int.class;
                //使用了通配符?（表示任何事物）
                Class<?> intClass = int.class;
                
                Class<?> intClass = int.class; 与 Class intClass = int.class; 是等价的，但使用Class<?>优于使用Class，因为它说明了你是明确要使用一个非具体的类引用，才选择了一个非具体的版本，而不是由于你的疏忽。
                    
            通配符?是Java泛型的一部分，?表示“任何事物”。向Class引用添加泛型语法的原因仅仅是为了提供编译期类型检查。
            
            将通配符与extends关键字相结合如Class<? extends Number>，就创建了一个范围，使得这个Class引用被限定为Number类型或其子类型。
        
        11. 类型转换前先做检查
            
            RTTI的几种表现形式：
                
                1）传统的类型转换，如"(Shape)"。由RTTI确保类型转换的正确性，若执行了一个错误的类型转换，抛出ClassCastException异常。（Java中，此操作要执行类型检查，有向上转型和向下转型两种）
                
                2）代表对象的类型的Class对象。通过查询Class对象可以获取运行时所需的信息。
                
                3）关键字instanceof，它返回一个布尔值，告诉我们对象是不是某个特定类型的实例。
                
                4）Class.isInstance()方法提供了一种动态测试对象的途径。Class.isInstance()方法使我们不再需要instanceof表达式。
                
            Class.isAssignableFrom() ：调用类型可以被参数类型赋值，即判断传递进来的参数是否属于调用类型继承结构（是调用类型或调用类型的子类）。
        
        12. instanceof 与 Class 的等价性
            
            instanceof 和 isInstance() 保持了类型的概念，它指的是“你是这个类吗，或者你是这个类的派生类吗？”
            
            == 和 equals() 没有考虑继承——它要么是这个确切的类型，要么不是。

        13. 反射：运行时的类信息
        
            反射提供了一种机制——用来检查可用的方法并返回方法名。
            
            Class类与 java.lang.reflect类库一起对反射的概念进行了支持。
            
            RTTI与反射的真正区别在于：
            
                1）对于RTTI来说，是编译时打开和检查.class文件。（换句话说，我们可以用“普通”方式调用对象的所有方法。）
                
                2）对于反射机制来说，.class文件在编译时是不可获取的，所以是在运行时打开和检查.class文件        
        
        14. 动态代理
                        
            Java的动态代理比代理的思想更向前迈进了一步，因为它可以动态地创建代理并动态地处理对所代理方法的调用。
            
            在动态代理上所做的所有调用都会被重定向到单一的调用处理器上，它的工作是揭示调用的类型并确定相应的对策。
            
            通过调用静态方法Proxy.newProxyInstance()可以创建动态代理，需要三个参数：
                
                ClassLoader loader 一个类加载器，通常可以从已经被加载的对象中获取其类加载器
                
                Class<?>[] interfaces 一个希望代理要实现的接口列表（不是类或抽象类）
                
                InvocationHandler h 一个调用处理器接口的实现
            
            动态代理可以将所有调用重定向到调用处理器，因此通常会向调用处理器传递一个“实际”对象（即被代理的对象）的引用，从而使得调用处理器在执行其中介任务时，可以将请求转发（即去调用实际对象）。
            
            动态代理的优点及美中不足
            
                优点：动态代理与静态代理相较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法（InvocationHandler.invoke）中处理。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。
                
                美中不足：它始终无法摆脱仅支持interface代理的桎梏，因为它的设计注定了这个遗憾。

        15. 空对象
                   
            空对象的逻辑变体是模拟对象和桩。
        
        16. 接口与类型信息
            
            interface关键字允许程序员隔离构件，降低耦合度。
            
            通过使用反射，可以到达并调用一个类的所有方法，包括私有方法！如果知道方法名，就可以在其Method对象上调用setAccessible(true)，然后访问私有方法。
    
    十五、泛型
    
        1. 泛型实现了参数化类型（parameterized types）的概念，使代码可以应用于多种类型。“泛型”这个术语的意思是：“适用于许多许多的类型”。
        
        2. 泛型方法
           
            泛型方法与其所在的类是否是泛型没有关系，即泛型方法所在的类可以是泛型类也可以不是泛型类。
           
            泛型方法使得该方法能够独立于类而产生变化 。
            
            一个基本指导原则：无论何时，只要你能做到，你就应该尽量使用泛型方法。也就是说如果使用泛型方法可以取代将整个类泛型化，那么就应该只使用泛型方法，因为它可以使事情更清楚明白。
            
            对于一个static方法而言，无法访问泛型类的类型参数，所以，如果static方法需要使用泛型能力，就必须使其成为泛型方法。
            
            要定义泛型方法，只需将泛型参数列表置于返回值之前。
        
        3. 类型参数推断
           
            使用泛型方法的时候，通常不必指明参数类型，因为编译器会为我们找出具体的类型。这称为类型参数推断（type argument inference）。
           
                类型推断只对赋值操作有效。
               
                如果将一个泛型方法调用的结果作为参数，传递给另一个方法，这时编译器并不会执行类型推断。
           
            显式的类型说明
           
                在点操作符与方法名之间插入尖括号，然后把类型置于尖括号内，即显式的类型说明。
        
        4. 擦除的神秘之处
        
            根据JDK文档的描述，Class.getTypeParameters()将“返回一个TypeVariable对象数组，表示有泛型声明的类型参数…..”，这好像是在暗示你可能发现参数类型的信息，但是，正如你从输出中看到，你能够发现的只是用作参数占位符的标识符，这并非有用的信息。
        
            因此，残酷的现实是：在泛型代码内部，无法获得任何有关泛型参数类型的信息。
        
            因此，你可以知道诸如泛型参数标识符和泛型类型边界这类信息——你却无法知道创建某个特定实例的实际的类型参数。……，在使用Java泛型工作时它是必须处理的最基本的问题。
        
            Java泛型是使用擦除来实现的，这意味着当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象。因此 List<String> 和 List<Integer> 在运行时事实上是相同的类型。这两种形式都被擦除成它们的“原生类型，即 List。
            
            擦除的问题
            
                擦除的核心动机是它使得泛化的客户端可以用非泛化的类库来使用，反之亦然，这经常被称为迁移兼容性。
            
                因此，擦除主要的正当理由是从非泛化的代码到泛化的代码的转变过程，以及在不破坏现有类库的情况下，将泛型融入Java语言。
            
                擦除的代码是显著的。
            
            擦除和迁移兼容性意味着，使用泛型并不是强制的。

                class GenericBase<T>{}
                class Derived1<T> extends GenericBase<T>{}
                class Derived2 extends GenericBase{} // No warning
                
            边界处的动作
            
                即使擦除在方法或类内部移除了有关实际类型的信息，编译器仍旧可以确保在方法或类中使用的类型的内部一致性。
                
                因为擦除在方法体中移除了类型信息，所以在运行时的问题就是边界：即对象进入和离开方法的地点。这些正是编译器在编译期执行类型检查并插入转型代码的地点。
                
                在泛型中的所有动作都发生在边界处——对传递进来的值进行额外的编译期检查，并插入对传递出去的值的转型。这有助于澄清对擦除的混淆，记住，“边界就是发生动作的地方。”

        5. 擦除的补偿（Compensating for erasure）
           
            有时必须通过引入类型标签（type tag）来对擦除进行补偿（compensating）。这意味着你需要显示地传递你的类型的Class对象，以便你可以在类型表达式中使用它。

        6. 边界（bound）
           
            边界使得你可以在用于泛型的参数类型上设置限制条件。尽管这使得你可以强制规定泛型可以应用的类型，但是其潜在的一个更重要的效果是你可以按照自己的边界类型来调用方法。
            
            因为擦除移除了类型信息，所以，可以用无界泛型参数调用的方法只是那些可以用Object调用的方法。
            
            但是，如果能够将这个参数限制为某个类型子集，那么你就可以用这些类型子集来调用方法。
            
            通配符被限制为单一边界。

        7. 通配符（wildcards）
                       
            数组的一种特殊行为：
              
                可以将子类型的数组赋给基类型的数组引用。然后编译期数组元素可以放置基类型及其子类型的元素，即编译时不报错，但运行时的数组机制知道实际的数组类型是子类，因此会在运行时检查放置的类型是否是实际类型及其再导出的子类型，不是则抛出java.lang.ArrayStoreException异常。
            
            容器的类型与容器持有的类型一致。
            
                // Compile Error: incompatible types:
                List<Fruit> list = new ArrayList<Apple>();
            
            与数组不同，泛型没有内建的协变类型。即*协变性对泛型不起作用。
            
            逆变（Contravariance）
            
                使用超类型通配符。声明通配符是由某个特定类的任何基类界定的，方法是指定<? super MyClass>，甚至或者使用类型参数：<? super T>。这使得你可以安全地传递一个类型对象到泛型类型中。
            
            无界通配符（Unbounded wildcards）
            
                原生泛型Holder与Holder<?>
            
                原生Holder将持有任何类型的组合，而Holder<?>将持有具有某种具体类型的同构集合，因此不能只是向其中传递Object。
            
            捕获转换
            
                ？？？
        
        8. 问题
                       
            基本类型不能作为类型参数；
            
            由于探险，一个类不能实现同一个泛型接口的两种变体；
            
            由于擦除，通过泛型来重载方法将产生相同的签名，编译出错，不能实现重载；
            
            基类劫持了接口。

        9. ？？？
        
    十六、数组
    
        1. System.arraycopy()，用来实现数组之间的复制。
        
        2. ？？？    
        
    十七、容器深入研究
    
        1. Set和存储顺序
                       
            加入Set的元素必须定义equals()方法以确保对象的唯一性。
            
            hashCode()只有这个类被置于HashSet或者LinkedHashSet中时才是必需的。但是对于良好的编程风格而言，你应该在覆盖equals()方法时，总是同时覆盖hashCode()方法。
            
            如果一个对象被用于任何种类的排序容器中，例如SortedSet（TreeSet是其唯一实现），那么它必须实现Comparable接口。
            
            注意，SortedSet的意思是“按对象的比较函数对元素排序”，而不是指“元素插入的次序”。插入顺序用LinkedHashSet来保存。
        
        2. 队列
                       
            除了并发应用，Queue在Java SE5中仅有的两个实现是LinkiedList和PriorityQueue，它们仅有排序行为的差异，性能上没有差异。
            
            优先级队列PriorityQueue的排列顺序也是通过实现Comparable而进行控制的。

        3. Map
           
            映射表（也称为关联数组Associative Array）。
            
            性能
           
                HashMap使用了特殊的值，称作散列码（hash code），来取代对键的缓慢搜索。散列码是“相对唯一”的、用以代表对象的int值，它是通过将该对象的某些信息进行转换而生成的。
                
                hashCode()是根类Object中的方法，因此所有对象都能产生散列码。
                
                对Map中使用的键的要求与对Set中的元素的要求一样：
                
                    任何键都必须具有一个equals()方法；
                    
                    如果键被用于散列Map，那么它必须还具有恰当的hashCode()方法；
                    
                    如果键被用于TreeMap，那么它必须实现Comparable。
        
        4. 散列与散列码
           
            HashMap使用equals()判断当前的键是否与表中存在的键相同。
            
            默认的Object.equals()只是比较对象的地址。如果要使用自己的类作为HashMap的键，必须同时重写hashCode()和equals()。
            
            正确的equals()方法必须满足下列5个条件：
                           
                自反性。
                
                对称性。
                
                传递性。
                
                一致性。
                
                对任何不是null的x，x.equals(null)一定返回false。
           
            4.1 散列概念
           
                使用散列的目的在于：想要使用一个对象来查找另一个对象。

                Map的实现类使用散列是为了提高查询速度。
                
                散列的价值在于速度：
                
                    散列使得查询得以快速进行。由于瓶颈位于查询速度，因此解决方案之一就是保持键的排序状态，然后使用Collections.binarySearch()进行查询。
                    
                    散列则更进一步，它将键保存在某处，以便能够很快找到。存储一组元素最快的数据结构是数组，所以用它来表示键的信息（请小心留意，我是说键的信息，而不是键本身）。但是因为数组不能调整容量，因此就有一个问题：我们希望在Map中保存数量不确定的值，但是如果键的数量被数组的容量限制了，该怎么办？
                    
                    答案就是：数组并不保存键本身。而是通过键对象生成一个数字，将其作为数组的下标。这个数字就是散列码，由定义在Object中的、且可能由你的类覆盖的hashCode()方法（在计算机科学的术语中称为散列函数）生成。
                    
                    为解决数组容量固定的问题，不同的键可以产生相同的下标。也就是说，可能会有冲突，即散列码不必是独一无二的。因此，数组多大就不重要了，任何键总能在数组中找到它的位置。
                    
            4.2 理解散列
           
                综上，散列就是将一个对象生成一个数字保存下来（作为数组的下标），然后在查找这个对象时直接找到这个数字就可以了，所以散列的目的是为了提高查找速度，而手段是将一个对象生成的数字与其关联并保存下来（通过数组，称为散列表）。这个生成的数字就是散列码。而生成这个散列码的方法称为散列函数（hashCode()）。
        
            4.3 HashMap查询过程（快速原因）
            
                HashMap中查询一个key的过程就是：
            
                    首先计算散列码；
                    
                    然后使用散列码查询数组（散列码作变数组下标）；
                    
                    如果没有冲突，即生成这个散列码的对象只有一个，则散列码对应的数组下标的位置就是这个要查找的元素；
                    
                    如果有冲突，则散列码对应的下标所在数组元素保存的是一个list，然后对list中的值使用equals()方法进行线性查询。
            
                因此，不是查询整个list，而是快速地跳到数组的某个位置，只对很少的元素进行比较。这便是HashMap会如此快速的原因。
        
        5. Collection或Map的同步控制
           
            Collections类有办法能够自动同步整个容器。其语法与“不可修改的”方法相似。
            
            快速报错（fail-fast）
            
                Java容器有一种保护机制能够防止多个进行同时修改同一个容器的内容。Java容器类类库采用快速报错（fail-fast）机制。
                
                它会探查容器上的任何除了你的进程所进行的操作以外的所有变化，一旦它发现其他进程修改了容器，就会立刻抛出ConcurrentModificationException异常。
                
                这就是“快速报错”的意思——即，不是使用复杂的算法在事后来检查问题。
        
    十八、Java I/O系统    
        
        1. File类
        
            File（文件）类这个名字有一定的误导性；我们可能会认为它指代的是文件，实际上却并非如此。它既能代表一个特定文件的名称，又能代表一个目录下的一组文件的名称。实际上，FilePath（文件路径）对这个类来说是更好的名字。

            如果它指的是一个文件集，我们就可以对此集合调用list()方法，这个方法会返回一个字符串数组。
            
        2. 输入和输出（Input an output）
           
            编程语言的I/O类库常使用流这个抽象概念，它代表任何有能力产出数据的数据源对象或者是有能力接收数据的接收对象。“流”屏蔽了实际的I/O设备中处理数据的细节。
            
            InputStream或Reader中的read()用于读取单个字节或者字节数组，OutputStream或Writer中的write()用于写单个字节或者字节数组。
            
            2.1 InputStream类型
            
                InputStream的作用是用来表示那些从不同数据源产生输入数据的类。每一种数据源都有相应的InputStream子类。这些数据源包括：
            
                    字节数组 -- new ByteArrayInputStream(bytes)
                    
                    String对象 -- new ByteArrayInputStream("Hello".getBytes("UTF-8"))
                    
                    文件 -- new FileInputStream(fileName)
                    
                    “管道”（A pipe），工作方式与实际管道相似，即，从一端输入，从另一端输出 -- new PipedInputStream()
                    
                    一个由其他种类的流组成的序列，以便我们可以将它们收集合并到一个流内 -- new SequenceInputStream()
                    
                    其他数据源，如Internet连接等 -- new FilterInputStream()
            
            2.2 OutputStream类型
            
              OutputStream类决定了输出所要去往的目标：
            
                字节数组 -- new ByteArrayOutputStream()
                
                文件 -- new FileOutputStream()
                
                管道 -- new PipedOutputStream()
                
                其他 -- new FilterOutputStream()

        3. 添加属性和有用接口
           
            FilterInputStream和FilterOutputStream是用来提供装饰器类接口以控制特定输入流（InputStream）和输出流（OutputStream）的两个类，它们的名字并不直观。这两个类是装饰器的必要条件（以便能为所有正在被修饰的对象提供通用接口）。                
            
            FilterInputStream
                
                DataInputStream
                
                BufferedInputStream
                
                PushbackInputStream
            
            FilterOutputStream
            
                DataOutputStream
                
                BufferedOutputStream
                
                PrintStream
                
        4. Reader和Writer
                       
            InputStream和OutputStream面向字节形式的I/O提供功能。
            
            Reader和Writer面向字符（兼容Unicode）形式的I/O功能。

        5. 自我独立的类：RandomAccessFile
                       
            RandomAccessFile适用于由大小已知的记录组成的文件，所以我们可以使用seek()将记录从一处转移到另一处，然后读取或者修改记录。
            
            RandomAccessFile拥有和别的I/O类型本质不同的行为，因为我们可以在一个文件 内向前和向后移动。在任何情况下，它都是自我独立的，直接从Object派生而来。
            
        6. I/O流的典型使用方式（Typical uses of I/O streams）
            
            缓冲输入文件（Buffered input file）
            
            从内存输入（Input from memory）
            
            格式化的内存输入（Formatted memory input）
            
            基本的文件输出（Basic file output）
            
            存储和恢复数据（Storing and recovering data）
            
            读写随机访问文件（Reading and writing random-access files）
            
            管道流（PipedStreams）
        
        7. 压缩
        
            CheckedInputStream
            
            CheckedOutputStream
                                    
            InflaterInputStream
            
            InflaterOutputStream
            
            DeflaterInputStream
            
            DeflaterOutputStream
                       
            ZipInputStream
            
            ZipOutputStream
            
            GZIPInputStream
            
            GZIPOutputStream

        9. 对象序列化（Object serialization）
           
            Java的对象序列化将那些实现了Serilizable接口的对象转换成一个字节序列，并能够在以后将这个字节序列完全恢复为原来的对象。这一过程甚至可通过网络进行，这意味着序列化机制能自动弥补不同操作系统之间的差异。
            
            就其本身来说，对象的序列化是非常有趣的，因为利用它可以实现轻量级持久性（ligthweight persistence）。持久性意味着一个对象的生存周期并不取决于程序是否正在执行，它可以生存于程序的调用之间。
            
            对象序列化的概念加入到语言中是为了支持两种主要特性：
            
                一是Java的远程方法调用（Remote Method Invocation, RMI），它使存活于其他计算机的对象使用起来就像是存活于本机上一样。当向远程对象发送消息时，需要通过对象序列化来传输参数和返回值。
                
                再者，对Java Beans来说，对象的序列化也是必需的。使用一个Bean时，一般情况下是在设计阶段对它的状态信息进行配置。这种状态信息必须保存下来，并在程序启动时进行后期恢复；这种具体工作就是由对象序列化完成的。
            
            序列化一个对象和反序列化：
            
                首先要创建一个ObjectOutputStream对象，要通过构造函数含有一个 OutputStream 对象。
                
                然后，只需调用 void writeObject(Object obj)，即可将对象obj序列化，即转换成字节序列输出到第一步所说的Outputstream。
                
                反序列化，即将字节序列还原为一个对象，则只需调用ObjectInputStream的Object readObject()，输入到一个InputStream。
            
            寻找类
            
                反序列，即将字节序列还原为对象时，必须保证Java虚拟机能够找到要还原的对象的相关.class文件，否则抛出java.lang.ClassNotFoundException异常。
            
            序列化的控制
            
                如果只希望一个对象的某些信息序列化而某些信息不序列化，即进行序列化控制，可使用Externalizable接口。 
                
                Externalizable接口继承自Serializable接口，有两个方法如下，这两个方法会在序列化和反序列化过程中被自动调用。
                
                    void writeExternal(ObjectOutput obj)，在该方法内部只对所需部分进行显式序列化。
                    
                    void readExternal(ObjectInput in)
            
            Externalizable接口与Serializable接口区别：
            
                Externalizable只序列化writeExternal()中的部分，而Serializable自动地全部序列化。
                
                Externalizable在反序列化时（即调用readObject()时），会首先调用所有普通的默认构造器，然后调用readExternal()。
                
                Serializable在反序列化时，对象完全以它存储的二进制位为基础来构造，而不用调用构造器。

            transient（瞬时）关键字
            
                如果我们正操作的是一个Serializable对象，那么所有序列化操作都会自动进行。为了能够予以控制，可以用transient（瞬时）关键字逐个字段地关闭序列化，它的意思是“不用麻烦你保存或恢复数据——我会自己处理的”。
            
                由于Externalizable对象在默认情况下不保存任何字段，所以transient关键字只能和Serializable对象一起使用。

            序列化的持久性
            
                我们可以通过一个字节数组来使用对象序列化，从而实现对任何可Serializable对象的“深度复制”（deep copy）——深度复制意味着我们复制的是整个对象网，而不仅仅是基本对象及其引用。
            
                一个对象被序列化在单一流中，就可以恢复出与我们写出时一样的对象网，并且没有任何意外重复复制出的对象。
                
                一个对象被序列化在不同流中，再从不同流恢复时，得到的对象地址不同。

            注意：对象序列化的一个重要限制是它只是Java的解决方案：只有Java程序才能反序列化这种对象。一种更具互操作性的解决方案是将数据转换为XML格式，这可以使其被各种各样的平台语言使用。
                        
        10. Preferences
        
            对一款人性化的应用来说，往往需要存储用户的偏好设置，例如字体大小、应用风格等个性化的设置数据。
            
            Java应用具有跨平台的特性，就更需要一种平台无关的存储手段。Java官方给出的解决方案是Preferences首选项。
            
            Preferences的中文意思即偏好或喜好的意思，也就是说同一个程序在每次运行完后，可以通过Preferences来记录用户的偏好，下次启动时，程序会利用这些信息来了解用户的喜好。
            
            而这些信息在不同的操作系统中，Preferences底层的存储方式是不一样的。例如，在Windows下是将数据存储在注册表中，而在Linux下则是将数据存储在文件系统中的。
            
            在Preferences中，使用了树状结构来进行数据的存储，这主要是为了避免文件名冲突。我们需要知道的是，Preferences中有着两棵独立的树。一棵是用户首选项树，一棵是系统首选项树。在用户首选项树中，一般存储应用程序的个性化设置，如字体大小、字体颜色等。而系统首选项树是全局共享的，一般用来设置应用程序的配置数据。通常我们使用用户首选项树即可。
            
            在每棵首选项树中，存在着许多节点，我们的数据就存储在这些节点中。每个节点都有一个节点名，并且节点名可以不唯一，但是节点名中不可以包含“/”字符。同时，每个节点都有一个绝对路径名，这是唯一的。首选项树的根节点绝对路径名是“/”，它的子节点则是“/”+子节点名，其他节点的绝对路径命名方式与此类似。对根节点之外的任何一个节点来说，其绝对路径都是父节点的绝对路径+“/”+当前节点名。在每个节点对应的Preferences对象中，使用键值对的方式来存储和获取数据，这类似于HashMap的使用方式。
        
    十九、枚举类型
    
        1. 关键字enum可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用。
        
        2. 基本特性
        
            创建enum时，编译器会为你生成一个相关的类，这个类继承自java.lang.Enum类。
            
            enum可以添加方法，甚至可以有main方法。
            
            enum的values()方法可以遍历enum实例，values()方法返回enum实例数组，且数组中元素保持在enum声明时的顺序。
            
            使用static import能够将enum实例的标识符带入当前命名空间，无需再用emum类型来修饰enum实例。
            
            覆盖enum的toString()方法和覆盖一般类的方法没有区别。
            
            enum提供了非常便利的功能：在switch中使用enum。
            
            可以通过提供一个带参构造器来实现枚举实例的带参初始化，以存储该实例相关的描述信息。
            
            如果在enum中打算自定义方法，那么必须在最后一个enum实例后添加一个分号，必须先定义enum实例，再定义方法。
            
            
            
            
            
        3. values()的神秘之处
           
            通过反编译枚举类，values()是由编译器添加的static()方法。编译器将枚举类（enum）标记为final类，所以enum类无法被继承。
            
            编译器还添加了valueOf()方法。
            
            添加的这个valueOf()方法和Enum中的valueOf()方法不同。前者只有一个参数而后者有两个。
            
            由于values()方法是由编译器插入到enum定义的static方法，当enum实例向上转型为Enum，values()方法就不能调用了。
            
            Class中有个getEnumConstants()方法可以获取到所有enum实例。
        
        4. 实现而非继承
           
            所有的enum类都继承自java.lang.Enum类。由于Java不支持多重继承，所以你的enum类不能再继其他类，然而，在我们创建一个新的enum时，可以同时实现一个或多个接口。
        
        5. 使用接口组织枚举
        
            在一个接口的内部，创建实现该接口的枚举，以此将元素进行分组，可以达到枚举元素分类组织的目的。对于enum而言，实现接口是使其子类化的唯一方法。
            
        6. 使用EnumSet替代标志
        
            由于不能从enum中删除或添加元素，所以引入EnumSet，以替代传统的基于int的“位标志”。EnumSet将一个long值作为比特向量，其中的元素必须是enum类型。
             
            一个long值有64位，而一个enum实例只需一个bit表示其是否存在。也就是说，在不超过一个long的表达能力下，EnumSet可以应用于最多不超过64个元素的enum，如果超过64个，Enum会在必要的时候增加一个long。
        
        7. 使用EnumMap
        
            EnumMap要求其中的键来自一个enum。与EnumSet一样，enum实例定义的次序决定了其在EnumMap中的顺序。即使没有调用put方法，enum的每个实例作为EnumSet的一个键都存在，只不过没有值。
        
        8. 常量相关的方法
        
            enum允许为enum实例编写方法，从而为每一个enum实例赋予不同的行为。要实现常量相关的方法，需要为enum定义一个或多个abstract方法，然后为每个enum实例实现该抽象方法，有点像匿名类。
        
            不能将enum实例作为一个类型来使用，因为每个enum实例都是一个enum类型的static final实例。由于是static实例，所以无法访问外部类的非static元素或方法。
            
            enum类允许覆盖常量相关的方法。
            
            枚举类型适合用来创建状态机，一个状态机可以具有有限个特定状态，它通常根据输入，从一个状态转移到下一个状态，非常适合用来表现不同的状态和输入。
            
        9. 多路分发
        
            Java只支持单路分发，如果要执行的操作包含了不止一个类型未知的对象时，Java的动态绑定机制只能处理其中之一的类型。
            
            多态只能发送在方法调用时，所以如果想使用两路分发，那么就必须有两个方法调用：第一个方法调用决定第一个未知类型，第二个方法调用决定第二个未知类型。一般需要设定好某种配置，以便一个方法调用能够引出更多的方法调用。
            
            使用enum分发：使用构造器来初始化每个enum实例，并以一组结果作为参数，这两者放在一块，形成了类似查询表的结构。
            
            由于通配符不能拓展多个基类，所以最好不要在把Class<T>中的T用通配符取代。
            
            常数相关的方法允许为每个enum实例提供不同方法实现，最好的办法是把enum用在switch中。
            
            使用EnumMap可以实现两路分发。
            
            使用enum类内定义的二维数组，每个enum实例都有一个固定的值（基于其声明的次序），但它只能针对给定的常量输入产生常量输出。
        
    二十、注解
    
        1. 注解（也被称为元数据）为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便地使用这些数据。
        
            被注解的方法与其他的方法没有区别。注解可以与任何修饰符共同作用于方法，例如，public, static或void。从语法的角度来看，注解的使用方式几乎与修饰符的使用一模一样。
                    
            java提供了一套机制，使得我们可以对方法、类、参数、包、域以及变量等添加标注(即附上某些信息)。且在以后某个时段通过反射将标注的信息提取出来以供使用。 
        
            注解相当于一种标记，在程序中加了注解就等于为程序打上了某种标记。程序可以利用java的反射机制来了解你的类及各种元素上有无何种标记，针对不同的标记，就去做相应的事件。
            
            注解不支持继承。
        
        2. 基本注解
           
            在java.lang包下，JAVA提供了5个基本注解：
           
                @Override 
           
                    限定重写父类方法。对于子类中被@Override 修饰的方法，如果存在对应的被重写的父类方法，则正确；如果不存在，则报错。@Override 只能作用于方法，不能作用于其他程序元素。
           
                @Deprecated
           
                    用于表示某个程序元素（类、方法等）已过时。如果使用了被@Deprecated修饰的类或方法等，编译器会发出警告。
           
                @SuppressWarnings
           
                    抑制编译器警告。指示被@SuppressWarnings修饰的程序元素（以及该程序元素中的所有子元素，例如类以及该类中的方法.....）取消显示指定的编译器警告。例如，常见的@SuppressWarnings（value="unchecked"）
           
                    SuppressWarnings注解的常见参数值的简单说明：
           
                        1）deprecation：使用了不赞成使用的类或方法时的警告(使用@Deprecated使得编译器产生的警告)；
                        
                        2）unchecked：执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型; 关闭编译器警告
                        
                        3）fallthrough：当 Switch 程序块直接通往下一种情况而没有 Break 时的警告;
                        
                        4）path：在类路径、源文件路径等中有不存在的路径时的警告;
                        
                        5）serial：当在可序列化的类上缺少 serialVersionUID 定义时的警告;
                        
                        6）finally：任何 finally 子句不能正常完成时的警告;
                        
                        7）all：关于以上所有情况的警告。
           
                @SafeVarargs
           
                    @SafeVarargs是JDK 7 专门为抑制“堆污染”警告提供的。
           
                @FunctionalIterface   （java 8 新增的）
           
                    函数式接口。Java8规定：如果接口中只有一个抽象方法（可以包含多个默认方法或多个static方法），该接口称为函数式接口。
           
                    @FunctionalInterface就是用来指定某个接口必须是函数式接口，否则就会编译出错。    
        
        3. 元注解：
           
            @Target 表示该注解可以用于什么地方。
            
            @Retension 表示需要在什么级别保存该注解信息。
            
            @Documented 将此注解包含在Javadoc中。
            
            @Inherited 允许子类继承父类中的注解。
                    
        4. JDK1.8新增注解
                       
            @Repeatable 可重复注解的注解，允许在同一申明类型（类，属性，或方法）的多次使用同一个注解。
            
            @Native 仅仅用来标记native的属性，且只在代码中使用，一般用于给IDE工具做提示用。表示被注解的内容是原生(本机)相关的。不影响java本身代码逻辑，通常用于生成JNI相关的头文件。
        
        5. 定义注解
        
            注解的定义看起来很像接口的定义。事实上，与其他任何Java接口一样，注解也将会编译成class文件。

            定义注解时会需要一些元注解（meta-annotation），如@Target，@Retention。

            在注解中，一般都会包含一些元素以表示某些值。当分析处理注解时，程序或工具可以利用这些值。注解的元素看起来就像接口的方法，唯一的区别是你可以为其指定默认值。元素的类型有限制。

            没有元素的注解称为标记注解（marker annotation）。

            所有注解都继承了Annotation。
            
            定义形式：
                
                1）以@interface关键字定义
                
                2）注解需要标明注解的生命周期，注解的修饰目标等信息，这些信息是通过元注解实现。
        
        6. 关于注解   
        
            注解元素的类型有限制，不可以是任意类型，使用除允许类型以外的类型编译器会报错。
        
            默认值限制：
                
                首先，元素不能有不确定的值。也就是说，元素必须要么具有默认值，要么在使用注解时提供元素的值。
                
                其次，对于非基本类型的元素，无论是在源代码中声明时，或是在注解接口中定义默认值时，都不能以null作为其值。
                
                这个约束使得注解处理器很难表现一个元素的存在或缺失的状态，因为在每个注解的声明中，所有的元素都存在，并且都具有相应的值。
                
                为了绕开这个约束，我们只能自己定义一些特殊的值例如空字符串或负数，以此表示某个元素不存在：
        
                    @Target(ElementType.METHOD)
                    @Retention(RetentionPolicy.RUNTIME)
                    public @interface SimulationNull{
                        public int id() default -1;
                        public String description() default "";
                    }
        
            生成外部文件。有些framework需要一些额外的信息才能与你的源代码协同工作，而这种情况最适合注解表现其价值了。像Enterprise JavaBean这样的技术，需要部署描述文件。Web Service、自定义标签库以及对象/关系映射工具（如Toplink和Hibernate）等，一般都需要XML描述文件，而这些描述文件脱离于源代码之外。
        
        7. 编写注解处理器
           
            使用注解的过程中，很重要的一部分就是创建与使用注解处理器，用来读取注解。
                
                反射机制的API可以构造注解处理器。
                
                外部工具apt可以解析带有注解的Java源代码。
            
            当定义好Annotation注解后，接下来就需要一个注解处理器来处理自定义注解。实现Java Annotation一般需要继承AbstractProcessor抽象类，并且重写其四个方法来实现提取。
            
    二十一、并发
    
        1.  顺序编程，即程序中的所有事物在任意时刻都只能执行一个步骤。并发编程，程序能够并行地执行程序中的多个部分。
        
        2. 并发的多面性
                       
            更快的执行。
            
            改进代码设计。

        3. 基本的线程机制
        
            并发编程使得我们可以将程序划分为多个分离的、独立的任务。通过使用多线程机制，这些独立任务中的每一个都将由执行程序来驱动。一个线程就是进程中的一个单一的顺序控制流，因此，单个进程可以拥有多个并发执行的任务，但是你的程序使得每个任务都好像有其自己的 CPU 一样。
            
            线程模型为编程带来了便利。它简化了在单一程序中同时多个操作的处理。在使用线程时，CPU 将轮流给每个任务分配其占用时间。每个人物都觉得自己在一直占用 CPU，但事实上 CPU 时间是划分片段分配给了所有任务（也有可能是运行是多个 cpu 之上）。
            
            线程的一大好处是可以使你从这个层次抽身出来，即代码不需要知道它是运行在一个还是多个 CPU 上。所以，使用线程机制是一个建立透明的，可扩展的程序的方法，如果程序运行速度太慢，为机器增添一个 CPU 就很容易的增加程序运行的速度。多个任务，多个线程是使用多处理器系统的最合理方式。
            
        4. 定义任务
           
            线程可以驱动任务，因此你需要一种描述任务的方式，这可以由Runnable接口来提供。要想定义任务，只需实现Runnable接口并编写run()方法，使得该任务可以执行你的命令。
            
            当从Runnable导出一个类时，它必须具有run()方法，但是这个方法并无特殊之处——它不会产生任何内在的线程能力。要实现线程行为，你必须显式地将一个任务附着到线程上。
                        
            1）实现Runnable接口：new Thread(Runnable).start();
            
                将任务与线程分离，符号面向对象思想，适合多个线程处理统一资源的情况。
                
                可实现多重继承，避免单继承带来的局限性。
                
                有利于程序的健壮性，代码能够被多个线程共享。
            
            2）继承Thread类：重写run方法，new Thread(){run()}.start();
                
                不能在继承其他类。
                
                编写简单，可直接操纵线程，无需使用Thread.currentThread()。
            
            3）使用Executor
            
                使用线程池的好处：
                                    
                    降低资源消耗。通过重复利用已创的线程降低线程创建和销毁带来的消耗。
                    
                    提高响应速度。当任务到达的时候，不需要再去创建线程就能立即执行。
                    
                    提高线程的可管理性。线程是稀缺资源，如果无限制的创建不仅会耗尽系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控。
                    
                几种常用的线程池：
                
                    newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
                        
                        这种类型的线程池特点是：
                        
                            工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。
                            
                            如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。
                            
                            在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。

                    newFixedThreadPool：创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。
                    
                        FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。
                    
                    newSingleThreadExecutor：创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。
                    
                        单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。                   
                    
                    newScheduleThreadPool：创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。
    
                线程池底层实现：
                    
                    public ThreadPoolExecutor(int corePoolSize,                  // 线程池的基本大小
                                              int maximumPoolSize,               // 线程池的最大大小
                                              long keepAliveTime,                // 线程活动保持时间
                                              TimeUnit unit,                     // 线程活动保持时间单位
                                              BlockingQueue<Runnable> workQueue, // 任务队列
                                              ThreadFactory threadFactory,       // 线程工程
                                              RejectedExecutionHandler handler)  // 饱和策略
        
            4）从任务中产生返回值
              
                Runnable 是执行工作的独立任务，但是他不反回任何值。如果你希望在任务执行完成时能够返回值，那么可以实现 Callable 接口。它是具有类型参数的泛型，它的类型参数表示的是从方法 call() 中返回的值，并且必须使用 ExecutorService.submit() 方法调用它。
                
                submit 方法会产生 Future 对象，它用 Callable 返回结果的特定类型进行了参数化。可以使用 isDone() 方法查询 Future 对象是否完成。当任务完成时可以调用 get() 方法获取结果。
        
            5）休眠
              
                影响任务行为的一种简单方法是调用 sleep()，这将使任务终止执行给定的时间。
            
            6）优先级
              
                线程的优先级将线程的重要性传递给调度器。尽管 CPU 处理线程集的顺序是不确定的，但是调度器将倾向于让优先权告的线程先执行。然而并不意味着优先级低的线程得不到执行。优先级低的线程仅仅意味着执行的频率较低。
                
                在绝大多数时间所有的线程都应该以默认的优先级运行。试图操纵线程优先级通常是一种错误的做法。
            
            7）让步
              
                如果你已经知道你的一次循环迭代过程中的工作已经完成，就可以给线程调度机制一个暗示：你的工作完成的差不多了，可以让别的线程使用CPU了。这个暗示将通过调用yield()来完成。注意，这只是一种暗示，没有任何机制保证它将会被采纳。当调用 yield() 时，你也是在建议具有相同优先级的其他线程可以运行。
              
            8）后台线程
              
                后台线程就是指在程序运行的时候在后台提供一种通用服务的线程，这种线程不是程序必须的一部分。因此，当所有的非后台线程结束时，程序也就终止了，同时户杀死进程中的所有后台进程。反过来说，只要有任何非后台进程还在运行，程序就不会被终止。比如 main() 就是一个非后台线程。
              
            9）编码的变体
            
                ？？？
            
            10）加入一个线程
               
                一个线程可以在其他线程之上调用 join() 方法，其效果是等待一段时间直到被调用 join() 的线程结束才继续执行。如果某个线程在另一个线程 t 上调用 join() 方法，此线程将会被挂起，直到目标线程 t 结束才恢复。也可以在调用 join() 时带上一个超时参数，这样如果目标线程在这段时期没有完成结束，join() 方法总能返回。对 join() 方法的调用可以被中断，做法是在调用线程上调用 interrupt() 方法。
            
            
            11）线程组
               
                线程组持有一个线程集合。线程组的价值可以引用Joshua Bloch的话来总结：“最好把线程组看成是一次不成功的尝试，你只要忽略它就好了。”

                如果你花费了大量的时间和精力试图发现线程组的价值（就像我一样），那么你可能会惊异，为什么没有来自Sun的关于这个主题的官方声明，多年以来，相同的问题对于Java发生的其他变化也询问过无数遍。诺贝尔经济学将得主Joseph Stiglitz的生活哲学可以用来解释这个问题，它被称为承诺升级理论（The Theory of Escalating Commitment）：“继续错误的代价由别人来承担，而承认错误的代价由自己承担。”

            12）捕获异常
               
                由于线程的本质特征，使得你不能捕获从线程中逃逸的异常。一旦异常逃出任务的 run() 方法，它就会向外传播到控制台，除非你采取特殊的步骤捕获这种错误的异常。在 Java SE5 之后，可以用 Executor 来解决这个问题。
                
                在JavaSE5之前，可以使用线程组来捕获这些异常。现在可以修改Executor产生线程的方式。Thread.UncaughtExceptionHandler是Java SE5中的新接口，它允许在每个Thread对象上都附着一个异常处理器。Thread.UncaughtExceptionHandler.uncaughtException()会在线程因未捕获的异常而临近死亡时被调用。可以创建一个新类型的ThreadFactory，为每个新创建的Thread对象上附着一个异常处理器。
        
        5. 共享受限资源
           
            可以把单线程程序当作在问题域求解的单一实体，每次只能做一件事情。
            
            1）不正确地访问资源
           
                因为canceled标志是boolean类型的，所以它是原子性的，即诸如赋值和返回值这样的简单操作在发生时没有中断的可能，因此你不会看到这个域处于在执行这些简单操作的过程中的中间状态。
           
                有一点很重要，那就是要注意到递增程序自身也需要多个步骤，并且在递增过程中任务可能会被纯种机制挂起——也就是说，在Java中，递增不是原子性的操作。因此，如果不保护任务，即使单一的递增也不是安全的。
            
            2）什么时候应该同步？
              
                运用Brian同步规则：如果你正在写一个变量，它可能接下来将被另一个线程读取，或者正在读取一个上一次已经被另一个线程写过的变量，那么你必须使用同步，并且读写线程必须使用相同的监视器锁同步。
            
            3）同步
              
                同步分为两种，一种是多个线程共享同一个资源，该资源同一时刻只能让一个线程访问，对共享资源的互斥访问，利用synchronized关键字或者Lock等实现。另一种是多个线程协作解决某一个问题，某个线程必须在另一个线程之前或者之后完成，线程之间的顺序问题，利用wait()和notify()实现。
            
            4）共享资源
              
                使用线程来同时运行多个任务时，可以通过使用锁来同步两个任务的行为，从而使得一个任务不会干涉另一个任务的资源。也就是两项任务在交替着步入某项资源，可以使用互斥来使得任何时刻只有一个任务可以访问这项资源。
                
                    关键字synchronized，为防止资源冲突提供内置支持。
                    
                    使用显示的Lock锁：Lock对象必须被显示的创建、锁定和释放。因此与内建锁相比，代码缺乏优雅性。
                    
                    原子性与易变性。
                    
                    原子类
                    
                        Java SE5 引入了诸如AtomicInteger、AtomicLong、AtomicReference等特殊的原子性变量类。
                    
                    线程本地存储（ThreadLocal）
                    
                        防止任务在共享资源上产生冲突的第二种方式是根除对变量的共享。线程本地存储是一种自动化机制，可以为使用相同变量的不同线程都创建不同的存储。如果有5个线程都要使用变量x所表示的对象，那线程本地存储就会生成5个用于x的不同的存储块。ThreadLocal对象通常当做静态域存储。
                    
                    
                    锁的等级：必须给定一个在其上的进行同步的对象。
                    
                    yield()让步
                        
                        当调用yield()时，是在建议具有相同优先级的其它线程可以运。
           
            5）终结任务
            
                Executor上调用shutdownNow()，它将发送一个interrupt()调用给它启动的所有线程。
                
                Executor 通过调用submit()而不是excutor()来启动任务，就可以持有该任务的上下文。submit()将返回一个泛型的Future<?>，持有这种Future的关键在于你可以在其上调用cancel()，并因此可以使用它来中断某个特定任务。如果你将true传递给cancel()，那么它就会拥有在该线程上调用interrupt()以停止这个线程的权限。因此，cancel()是一个种中断由Excutor启动的单个线程的方式。
                
                SleepBlock()是可中断的阻塞，而IOBlocked和SynchronizedBlocked是不可中断的阻塞。上面三个类的示例证明I/O和在synchronized块上的等待是不可中断的。无论是I/O还是尝试调用synchronized方法，都不需要任何InterruptedException处理器。
                
                从关于上面三个类的示例的输出中可以看到，你能够中断对sleep()的调用（或者任何要求抛出InterruptedException的调用）。但是，你不能中断试图获取synchronized锁或者试图执行I/O操作的线程。这有点令人烦恼，特别是在妊I/O的任务时，因为这意味着IO具有锁住你的多线程程序的潜在可能。特别是对于基于Web的程序，这更是关乎利害。
                
                对于这类问题，有一个略显笨拙但是有时确实行之有效的解决方案，即关闭任务在其上发生阻塞的底层资源。
                
                阻塞状态
                
                    一个任务进入阻塞状态的原因：
                    
                        通过调用sleep是任务进入休眠状态，在这种情况下，任务在制定的时间内不会运行。
                        
                        通过调用wait是线程挂起。直到线程得到了notify或者notifyAll消息，线程才会进入就绪状态。
                        
                        任务在等待某个输入/输出完成。
                        
                        任务试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了这个锁。
                
                中断
                
                    所谓中断就是在Runnable.run()方法的中间打断它。
                    
                退出阻塞任务的方法：
                
                    Thread类包含了interrupt()方法，因此你可以终止被阻塞的任务，这个方法将设置线程的中断状态。
                    
                        如果一个线程已经被阻塞，或者试图执行一个阻塞操作，那么设置这个线程的中断状态将抛出InterruptedException。当抛出该异常或者该任务调用Thread.interrupted()时，中断状态将被复位，Thread.interrupted()提供了离开run()循环而不抛出异常的第二种方式。
                        
                        为了调用interrupt()，必须持有Thread对象。
                        
                        能够中断对sleep()的调用，但是不能中断正在试图获取synchronized锁或者执行I/O操作的线程。
                        
                        在ReenTrantLock上阻塞的任务具备可以被中断的能力。lock.lockInterruptibly()。与I/O不同，Interrupt()可以打断被互斥所阻塞的调用。
                    
                退出无阻塞任务的方法：
                
                    如果想要调用interrupt()来停止某个任务，而在run()循环碰巧没有产生任何阻塞调用的情况下，退出任务需要第二种方式。
                    
                    可以通过调用Interrupted()来检查中断状态，这不仅可以告诉你interrupt()是否被调用过，而且还可以清除中断状态。清除中断状态可以确保并发结构不会就某个任务被中断这个问题通知你两次。
            
        6. 线程之间的协作
                    
            wait()、notify()、notifyAll()
                
                wait()：会等待外部世界产生变化的时候将任务挂起，并且只有在notify或者notifyAll发生时，即表示发生了某些感兴趣的事情，这个任务才会被唤醒并去检查所产的变化。wait()提供了一种任务之间对活动同步的方式。
                
                notify()：在众多等待同一个锁的任务中只有一个会被唤醒。注意的是在调用此方法时，并不能确切的唤醒某一个等待的线程，而是有JVM确定唤醒哪个线程，而不是按优先级。
                
                notifyAll()：将唤醒所有正在等待的任务。当notifyAll()因某个特定锁而被调用时，只有等待这个锁的任务才会被唤醒，注意不是给所有唤醒线程一个对象的锁，而是让它们竞争。
            
            wait()与sleep()的区别：
                
                sleep()是Thread的静态方法，谁调用谁就去睡觉；wait()是Object的方法。
                
                调用sleep()的时候锁并没有释放，调用yield()也属于这种情况。当一个任务在方法里遇到了对wait()的调用，线程的执行被挂起，对象的锁被释放。因为wait()将释放锁，这就意味着另一个任务可以获得这个锁，因此该对象中的其它的synchronized方法可以在wait()器件被调用。
                
                可以通过notify()、notifyAll()，或者令时间到期，从wait()中恢复执行。
                
                只能在同步控制方法或同步控制块里调用，sleep()可以在非同步控制方法里调用。
            
            为什么使用一个检查感兴趣的条件的while循环包围wait()?
                
                你可能有多个任务处于相同的原因在等待同一个锁，而第一个唤醒任务可能改变这种状态。如果属于这种情况，那么这个任务应该被再次挂起，直至有感兴趣的条件发生变化。
                
                在这个任务从起wait()中被唤醒的时刻，有可能有某个其他的任务已经做出了改变，从而是这个任务在此时不能执行，或者执行其操作已显得无关紧要。此时，应该再通过wait()来将其重新挂起。
                
                也可能某些任务处于不同的原因在等待你的对象上的锁（在这种情况下使用notifyAll()）。这种情况下，你需要检查是否已经有正确的原因唤醒，如果不是，就再次调用wait()。
            
            notify()与notifyAll()
            
                使用notify而不是notifyAll是一种优化。当notify()因某个特定的锁而被调用时，只有等待这个锁的任务才会被唤醒。

        7. 死锁
           
            某个任务在等待另一个任务，而后者有等待别的任务，这样一直下去，直到这个链条上的任务又在等待第一个任务释放锁。这得到了一个任务之间相互等待的连续循环，没有那一个线程能继续。这称之为死锁。
           
            死锁的四个必要条件；
           
                互斥条件：线程对所分配到的资源进行排他性使用，即在一段时间内，某资源只能被一个线程占用。如果此时还有其它线程请求该资源，则只能等待，直到占有该资源的线程用毕释放。
                
                请求和保持条件：已经保持了至少一个资源，但是又提出新的资源请求，而资源已被其他线程占有，此时请求线程只能等待，但对自己已获得的资源保持不放。
                
                不可抢占条件：线程已获得的资源在未使用完之前不能被抢占，只能线程使用完之后自己释放。
                
                循环等待条件：在发生死锁时，一个任务等待其他任务所持有的资源，后者又在等待另一个任务所持有的资源，这样一直下去，直到有一个任务所持有的资源，使得大家被锁住。
            
            哲学家就餐问题
            
                解决哲学家就餐死锁的办法就是破破坏循环等待条件：前面的哲学家先拿右边的再拿左边的，而最后一个哲学家先拿左边的在拿右边的。    
    
        8. 新类库中的构件
            
            1）CountDownLatch
              
                用来同步一个或多个任务，强制他们等待由其他任务执行的一组操作完成。
                
                可以向CountDownLatch对象设置一个初始计数值，任何在这个对象上调用await()方法都将阻塞，直至这个计数值到达0。其他任务在结束其工作时，可以调用countDown()来减小这个计数值。CountDownLatch被设计为只触发一次，计数值不能重置，如果需要能够重置计数值的版本，则可以使用CyclicBarrier。
            
            2）CyclicBarrier
              
                适用于这样的情况：你希望创建一组任务，他们并行的工作，然后在进行下一个步骤之前等待，直至所有的任务都完成。它使得所有的并行任务都将在栅栏处列队，因此可以一致的向前移动。
                    
            3）DelayQueue
            
                这是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，
            
            4）PriorityBlockingQueue
            
                这是一个很基础的优先级队列，它具有可阻塞的读取操作。这种队列的阻塞特性提供了所有必需的同步，所以你应该注意到了，这里不需要任何显式的同步——不必考虑当你从这种队列中读取时，其中是否有元素，因为这个队列在没有元素时，将直接阻塞读取者。
                
            5）ScheduledExecutor
            
                每个期望的时间都是一个在预定时间运行的任务。ShceduledThreadPoolExecutor提供了解决该问题的服务。通过使用schedule()（运行一次任务），或者scheduleAtFixedRate()（每隔规则的时间重复执行任务），可以将Runnable对象设置为在将来的某个时刻执行。
            
            6）Semaphore
            
                正常的锁在任何时刻都只允许一个人物访问一项资源，而计数信号量允许n个任务同时访问这个资源。需要的使用semaphore.acquire()方法申请，用完之后使用semaphore.release()释放。
            
            7）Exchanger
                
                是两个任务之间交换对象的栅栏。每个人在完成一定的事情之后想与对方交换数据，第一个拿出数据的人将一直等待第二个拿着数据到来时，才能彼此交换数据。两个任务通过同一个Exchange对象，分别调用它的exchange(data)方法，将需要交换的数据置于方法中。
    
        9. 仿真
            
            ？？？
            
        10. 性能调优
        
            比较各类互斥技术：
            
                Atomic类
                    
                    和上面的类似，不激烈情况下，性能比synchronized略逊，而激烈的时候，也能维持常态。激烈的时候，Atomic的性能会优于ReentrantLock一倍左右。但是其有一个缺点，就是只能同步一个值，一段代码中只能出现一个Atomic的变量，多于一个同步无效。因为他不能在多个Atomic之间同步。 
                
                关键字synchronized
                    
                    在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，原因在于，编译程序通常会尽可能的进行优化synchronize，另外可读性非常好，不管用没用过5.0多线程包的程序员都能理解。不能被中断。
                
                Lock
                    
                    在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态。
                    
                    ReentrantLock提供了多样化的同步，比如有时间限制的同步，可以被Interrupt的同步（synchronized的同步是不能Interrupt的）等。
                    
                    ReentrantLock 拥有Synchronized相同的并发性和内存语义，此外还多了 锁投票，定时锁等候和中断锁等候。可以被中断。
 
            免锁容器
                
                CopyOnWiteArrayList
                
                    写入将导致创建整个底层数组的副本，而原数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全的执行。当修改完成时，一个原子性的操作把新的数组换入，使得新的读取操作可以看到这个新的修改。
                    
                    好处是当多个迭代器同时遍历和修改这个列表时，不会抛出ConcurrentModificationException。
                    
                    CopyOnWriteArraySet将使用CopyOnWriteArrayList来实现其免锁行为。
                
                ConcurrenHashMap和ConcurrentLinkedQueue
                
                    使用了类似的技术，允许并发的读取和写入，但是容器中只有部分内容而不是整个容器可以被复制和修改。然而，在修改完成之前，读取者仍旧不能看到他们。
                
                ReadWriteLock
                
                    对向数据结构相对不频繁的写入，但是有多个任务要经常读取这个数据结构的这类情况进行了优化。ReadWriteLock使得你可以同时有多个读者，只要他们都不试图写入即可。如果写锁已经被其他任务持有，那么任何读者都不能访问，直至这个写锁被释放为止。即适用于读者多于写者的情况。
                
                    对于ReadWriteLock的应用主要是：缓存和提高对数据结构的并发性。
                
                    锁降级：重入还允许从写入锁降级为读取锁，其实现方式是：先获取写入锁，然后获取读取锁，最后释放写入锁。但是，从读取锁升级到写入锁是不可能的。
                    
                    锁获取的中断：读取锁和写入锁都支持锁获取期间的中断。
                    
                    Condition 支持 ：写入锁提供了一个 Condition 实现，对于写入锁来说，该实现的行为与 ReentrantLock.newCondition() 提供的 Condition 实现对 ReentrantLock 所做的行为相同。当然，此 Condition 只能用于写入锁。
                    
                    读取锁不支持 Condition，readLock().newCondition() 会抛出 UnsupportedOperationException。
                    
                    重入：此锁允许 reader 和 writer 按照 ReentrantLock 的样式重新获取读取锁或写入锁。在写入线程保持的所有写入锁都已经释放后，才允许重入 reader 使用它们。
    
    参考文献：
    
        1. https://www.cnblogs.com/cpacm/p/5568405.html