####Thinking In Java第四版学习笔记

    一、对象导论
        
        万物皆为对象。
        
        程序是对象的集合，它们通过发送消息来告知彼此所要做的。
        
        每个对象都拥有其类型。
        
        某一特定类型的所有对象都可以接收同样的消息。

    二、一切都是对象 
                
        栈（堆栈）：存放基本类型变量和对象引用变量。位于RAM区
        
        堆：存放new得到的对象和数组。也位于RAM区
        
        常量存储：存放常量，包括静态变量。
        
        1. new出来的对象都是放在堆里的。
        
        2. 基本数据类型（boolean、 byte、char、short、Int、long、float、double、void）存放在栈（堆栈）里。 
        
        3. Java中的数值类型不存在无符号的，它们的取值范围是固定的，不会随着机器硬件环境或者操作系统的改变而改变。
        
        4. BigInteger任意精度整数；BigDecimal任意精度定点数（可用于货币汇率转换）。
        
    三、操作符
     
        1. 赋值表达式是有值的，赋值表达式的值等于要赋的值。
        
        2. 移位操作符：
           
            $<<$：操作数向左移动，低位补0；
            
            $>>$：操作数向右移动，(1)符号为正时，高位补0，(2)符号为负时，高位补1；
            
            $>>>$：java独有操作符，操作数向右移动，高位统一补0。
            
            char，byte，short进行移位操作时先会转成int类型，即32位。
        
        3.三元运算符：
                      
            条件表达式？表达式1：表达式2。
            
            说明：问号前面的位置是判断的条件，判断结果为bool型，为true时调用表达式1，为false时调用表达式2。
        
        4. 将float或double转型为整数值时，总是对数字进行截尾，不会进行四舍五入。如果想要得到舍入的结果可以使用Math.round()。
        
        5. 如果对基本数据类型执行算数运算或按位运算，只要类型比int小（即char、byte或者short），那么在运算之前，这些值会自动转化成int。
        
            这样一来，最终生成的结果就是int类型。如果想把结果赋值给较小的类型，就必须使用类型转化。通常，表达式中出现的最大的数据类型决定了表达式最终结果的数据类型。
            
            如果将一个float值与一个double值相乘，结果就是double，如果将一个int和一个long值相加，则结果为long。
    
    四、控制执行流程
    
        1. returan关键词的用途：指定一个方法返回什么值（假设它没有void返回值），退出当前方法，并返回那个值。
        
        2. break用于强行退出循环，不执行循环中剩余的语句。而continue则停止执行当前的迭代，然后退回到循环起始处，开始下一次迭代。
        
            1）一般的continue会退回到最内层循环的开头，并继续执行。
            
            2）带标签的continue会达到标签的位置，并重新进入紧接在那个标签后面的循环。
            
            3）一般的break会中断并跳出当前循环。
            
            4）带标签的break会中断并跳出标签所指的循环。
            
            使用标签的唯一目的，就是因为循环嵌套的存在。用于多层嵌套的break和continue。
            
        3. switch 语句由一个控制表达式和多个case标签组成。
                 
            1）能用于switch判断的类型有：byte、short、int、char（JDK1.6），还有枚举类型，但是在JDK1.7后添加了对String类型的判断;
            
            2）case语句中少写了break，编译不会报错，但是会一直执行之后所有case条件下的语句而不再判断，一旦case匹配，就会顺序执行后面的程序代码，而不管后面的case是否匹配，直到遇见break或者default语句。
            
            3）若果没有符合条件的case就执行default下的代码块，default并不是必须的，也可以不写.
    
    五、初始化与清理
    
        1. 重载
                
            重载主要以传入参数及顺序来区别。不能通过返回值来区别
            
            以基本数据类型传入时:自动包装机制
            
                1）若传入的数据类型小于方法中声明的形式参数类型，实际数据类型就会提升。
                    
                    byte -> short -> int -> long -> float -> double
                
                2）如果传入的实际参数较大，就得通过类型转换执行窄化转换。
        
        2. this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。
            
             1）表示当前对象的引用；
             
             2）this调用本类中的属性和方法，也就是类中的成员变量和方法；
             
             3）this调用本类中的其他构造方法，调用时要放在构造方法的首行。
        
        3. super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。
        
            1）主要存在于导出类方法中，用于指向导出类对象中父类对象；
            
            2）访问父类的属性；
            
            3）访问父类的函数；
            
            4）问父类的构造函数。
            
        注意：
        
            如果开发者自定义了一个类，没有显示的进行类的继承，那么该类中成员函数是否可以使用super关键字？可以使用，任何类默认继承了Object类，Object类是所有类的父类。
            
            this和super很像，this指向的是当前对象的调用，super指向的是当前调用对象的父类。
            
            类加载完毕，创建对象，父类的构造方法会被调用（默认自动无参），然后执行导出类相应构造创建了一个导出类对象，该导出类对象还包含了一个父类对象。该父类对象在导出类对象内部。
            
            this和super只能在有对象的前提下使用，不能在静态上下文使用。
            
        super和this的异同：
        
            super（参数）：调用基类中的某一个构造函数（应该为构造函数中的第一条语句） 
            
            this（参数）：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句）
            
            super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名    super.成员函数据名（实参）
            
            this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）
            
            调用super()必须写在导出类构造方法的第一行，否则编译不通过。每个导出类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。
            
            super()和this()类似，区别是，super()从导出类中调用父类的构造方法，this()在同一类内调用其它方法。
            
            super()和this()均需放在构造方法内第一行。
            
            尽管可以用this调用一个构造器，但却不能调用两个。
            
            this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。
            
            this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量，static方法，static语句块。
            
            从本质上讲，this是一个指向本对象的指针， 然而super是一个Java关键字。
        
        4. static方法就是没有类中this的方法。
        
            在static方法的内部不能调用非静态方法，反之却可以。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。
            
        5. finalize()工作原理：一旦垃圾回收器准备释放对象占用的存储空间，将先调用其finalize()方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。所以你要是打算使用finalize()，就能在垃圾回收时刻做一些重要的清理工作。
            
            finalize方法，基本只会在java调用了native方法的时候，需要再通过native方法来释放它所占用的内存空间调用。
            
            finalize方法，是发生在jvm进行垃圾回收前调用的方法，所以这个方法所代表的含义就是在jvm垃圾回收前所需要做的有关于内存回收的操作。
            
            还有一种情况是，为了定位bug。
            
            对于finalize()方法的使用，就只有一条建议--------尽量不要使用！！！
            
        6. System.gc()用于强制进行终结动作。作用只是提醒虚拟机：程序员希望进行一次垃圾回收。但是它不能保证垃圾回收一定会进行，而且具体什么时候进行是取决于具体的虚拟机的，不同的虚拟机有不同的对策。
        
            不要使用gc函数，为了保持代码健壮姓（记得将不用的变量置为null），让虚拟机去管理内存。
        
        7. 垃圾回收
           
            1）垃圾收集算法的核心思想  
             
                Java语言建立了垃圾收集机制，用以跟踪正在使用的对象和发现并回收不再使用(引用)的对象。该机制可以有效防范动态内存分配中可能发生的两个危险：因内存垃圾过多而引发的内存耗尽，以及不恰当的内存释放所造成的内存非法引用。  

                垃圾收集算法的核心思想是：对虚拟机可用内存空间，即堆空间中的对象进行识别，如果对象正在被引用，那么称其为存活对象，反之，如果对象不再被引用，则为垃圾对象，可以回收其占据的空间，用于再分配。垃圾收集算法的选择和垃圾收集系统参数的合理调节直接影响着系统性能，因此需要开发人员做比较深入的了解。  
             
            2）触发主GC(Garbage Collector)的条件  
             
                JVM进行次GC的频率很高，但因为这种GC占用时间极短，所以对系统产生的影响不大。更值得关注的是主GC的触发条件，因为它对系统影响很明显。总的来说，有两个条件会触发主GC:  
             
                    ① 当应用程序空闲时，即没有应用线程在运行时，GC会被调用。因为GC在优先级最低的线程中进行，所以当应用忙时，GC线程就不会被调用，但以下条件除外。  
                    
                    ② Java堆内存不足时，GC会被调用。当应用线程在运行，并在运行过程中创建新对象，若这时内存空间不足，JVM就会强制地调用GC线程，以便回收内存用于新的分配。若GC一次之后仍不能满足内存分配的要求，JVM会再进行两次GC作进一步的尝试，若仍无法满足要求，则 JVM将报“out of memory”的错误，Java应用将停止。  

                由于是否进行主GC由JVM根据系统环境决定，而系统环境在不断的变化当中，所以主GC的运行具有不确定性，无法预计它何时必然出现，但可以确定的是对一个长期运行的应用来说，其主GC是反复进行的。  
             
            3）减少GC开销的措施  
             
               　根据上述GC的机制，程序的运行会直接影响系统环境的变化，从而影响GC的触发。若不针对GC的特点进行设计和编码，就会出现内存驻留等一系列负面影响。为了避免这些影响，基本的原则就是尽可能地减少垃圾和减少GC过程中的开销。具体措施包括以下几个方面:  
             
                (1) 不要显式调用System.gc()  
                
                    此函数建议JVM进行主GC，虽然只是建议而非一定，但很多情况下它会触发主GC，从而增加主GC的频率，也即增加了间歇性停顿的次数。  
                
                (2) 尽量减少临时对象的使用  
                
                    临时对象在跳出函数调用后，会成为垃圾，少用临时变量就相当于减少了垃圾的产生，从而延长了出现上述第二个触发条件出现的时间，减少了主GC的机会。  
                
                (3) 对象不用时最好显式置为Null  
                    
                    一般而言，为Null的对象都会被作为垃圾处理，所以将不用的对象显式地设为Null，有利于GC收集器判定垃圾，从而提高了GC的效率。  
                
                (4) 尽量使用StringBuilder，而不用String来累加字符串
                
                    由于String是固定长的字符串对象，累加String对象时，并非在一个String对象中扩增，而是重新创建新的String对象，如 Str5=Str1+Str2+Str3+Str4，这条语句执行过程中会产生多个垃圾对象，因为对次作“+”操作时都必须创建新的String对象，但这些过渡对象对系统来说是没有实际意义的，只会增加更多的垃圾。
                    
                    避免这种情况可以改用StringBuilder来累加字符串，因StringBuilder是可变长的，它在原有基础上进行扩增，不会产生中间对象。  
                
                (5) 能用基本类型如Int，Long，就不用Integer，Long对象  
                
                    基本类型变量占用的内存资源比相应对象占用的少得多，如果没有必要，最好使用基本变量。  
                
                (6) 尽量少用静态对象变量  
                
                    静态变量属于全局变量，不会被GC回收，它们会一直占用内存。  
                
                (7) 分散对象创建或删除的时间  
                
                    集中在短时间内大量创建新对象，特别是大对象，会导致突然需要大量内存，JVM在面临这种情况时，只能进行主GC，以回收内存或整合内存碎片， 从而增加主GC的频率。集中删除对象，道理也是一样的。它使得突然出现了大量的垃圾对象，空闲空间必然减少，从而大大增加了下一次创建新对象时强制主GC 的机会。

        8. 初始化顺序
           
            所有的变量都会在任何方法（包括构造器）被调用之前得到初始化。
            
            无论创建多少对象，静态数据都只占用一份存储区域，static不能作用于局部变量。且静态初始化动作只执行一次。
            
            成员初始化。初始化的顺序是，先静态对象，而后是“非静态对象”。对于方法的局部变量，如果没有初始化编译时会报未初始化的错。
           
            构造器初始化。可以使用构造器进行初始化，但是自动初始化将会在构造器被调用之前发生，给成员变量赋默认初始“零值”。
            
            静态数据的初始化。无论创建多少个对象，静态数据都只占用一份存储区域。static关键字不能应用于局部变量，因此它只能作用于域。如果一个域是静态的基本类型域，且也没有对它进行初始化。那么它会获得基本类型的标准初值。
            
            如果它是一个对象引用，那么它的默认初始值就是null。静态初始化动作只进行一次：当首次生成这个类的一个对象时，或者首次访问属于这个类的静态成员时（即便从未生成过那个类的对象）。
            
            数组初始化。数组只是相同类型的、用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。拥有的只是对数组的一个引用。数组的创建是在运行时刻进行的。可变参数列表。提供了一种方便的语法来创建对象并调用方法。由于所以的类都直接或间接继承于Object类，所以可以创建以Object数组为参数的方法。
            
            枚举类型。当创建枚举时，编译器会自动添加一些有用的特性，比如toString()方法，显示某个enum实例的名字。ordinal()方法，用来表示某个特定enum常量的声明顺序。static values()，用来按照enum常量的声明顺序，产生由这些常量值构成的数组。

        9. 可变参数列表
        
            定义：void method(Object... args){}
            
            调用：method()或method(new Object[]{1, 2, 3, 4});
    
    六、访问权限控制
    
        public的类、类属变量及方法，包内及包外的任何类均可以访问；
        
        protected的类、类属变量及方法，包内的任何类，及包外的那些继承了此类的导出类才能访问；
        
        private的类、类属变量及方法，类自己的内部类可以访问，其他任何类均不能访问；
        
        如果一个类、类属变量及方法不以这三种修饰符来修饰，它就是friendly类型的，那么包内的任何类都可以访问它，而包外的任何类都不能访问它(包括包外继承了此类的导出类)，因此，这种类、类属变量及方法对包内的其他类是友好的，开放的，而对包外的其他类是关闭的。

    七、复合类
    
        1. 导出类实例化的时候会默认调用父类的无参构造函数。
        
        2. 确保正确清理。许多情况下，清理并不是问题，仅需让垃圾回收器完成该动作就行。但当必须亲自处理清理时，就要多加小心。因为，垃圾回收器可能永远也无法被调用，即时被调用，它是按照任何它想要的顺序来回收对象。最好的办法是除了内存以外，不能依赖垃圾回收器去做任何事。如果需要清理，就自己写一个清理方法，但不要使用finalize()。
        
        3. 当你选择覆写某个方法时，可以选择添加这个@Override注解。
           
        4. 在组合与继承之间选择。组合和继承都允许在新的类中放置导出对象，组合是显式地这样做，而继承是隐式地做。一般来说很简单。如果是“is-a”的关系，那就使用继承。如果是“has-a”的关系，那就使用组合。
        
        6. protected关键字。在实际项目中，经常会想要将某些事物尽可能对这个世界隐藏起来，但仍允许导出类的成员访问它们。这时候便可以使用protected关键字。
           
        7. 向上转型。导出类引用向上转型成为基类引用。因为导出类一定具有基类的方法。所以这种转型是肯定可以的。类接口唯一可能发生的事情是丢失方法，而不是获取它们。
        
        8. final。意味着不可修改！
        
            1）final数据。
            
                1、一个永远不变的编译时常量。
                 
                2、一个在运行时被初始化的值，但不会再被改变。这是针对于基本数据类型。如果当final修饰一个引用的时候，那是意味着这个引用永远不能再改变了，不能再指向其他对象，但是对象的内容是可以改变的。
                
                注意： 一个既是static又是final的字段只占据一段不能修改的存储空间。
            
            2）空白final。所谓空白final指被声明为final但又未给定初值的字段。但编译器必须确保空白final在使用前必须被初始化。所以必须在字段的定义处或者每个构造器中用表达式对final进行赋值。
            
            3）final参数。Java允许在参数列表中以声明的方式将参数指明为final。这意味着你无法在方法中更改参数引用所指向的对象。
            
            4）final方法。使用final方法有两个原因。
            
                1、把方法锁定，以防任何继承类修改它的含义。可以确保在继承中使方法行为保持不变，并且不会被覆盖。
                
                2、使用final限定方法时。等于同意编译器将针对这个方法的所有调用转为内嵌调用。但现在一般只有要明确禁止覆盖时，才将方法设置为final。
            
            5）final和private关键字。类中的所有private方法都隐式地指定为是final。由于无法取用private方法，所以也就无法覆盖它。对private方法添加final修饰词是没有什么意义的。
            
            6）final类。当将某个类的整体定义为final时（通过关键字final置于它的定义之前），就表明了你不打算继承该类，并且也不允许别人这么做。
        
        9. 初始化及类的加载。
        
            Java中的所有事物都是对象。所以它采用了不同的加载方式。每个类的编译代码都在它自己的独立的文件之中，该文件只有需要使用程序代码时才会被加载。“类的代码在初次使用时才加载”。
        
            这通常是指加载发生在创建类的第一个对象之时，但是当访问static域或static方法时，也发生加载。初次使用之处也是static初始化发生之处。
            
            所有的static对象和static代码段都会在加载时依程序中的顺序（即，类定义时的书写顺序）而依次初始化并且只会被初始化一次。
            
            其实构造器也是static方法，尽管static关键字并没有显式地写出来。因此更准确地讲，类是在其任何static成员被访问时加载的。
           
            运行一个类时的加载顺序是这样的：
            
                假设该类名为Bettle。首先访问Beetle.main()（一个static方法），于是加载器开始启动并找出Beetle类的编译代码（在名为Beetle.class的文件之中）。
           
            在对它进行加载的过程中，编译器注意到它有一个基类（这是由关键字extends得知的），于是它继续进行加载。不管你是否打算产生一个该基类的对象，这都要发生。如果该基类还有其自身的基类，那么第二个基类就会被加载，如此类推。
            
            接下来，根基类中的static初始化即会被执行，然后是下一个导出类，以此类推。这种方式很重要，因为导出类的static初始化可能会依赖于基类成员能否被正确初始化。至此，必要的类都有已经加载完毕。于是就可以开始创建对象。
            
            首先，对象中所有的基本类型都会被设为默认值“零值”，对象引用被设为null--这是通过将对象的内存设为二进制零值而一举产生的。然后，基类的构造器会被调用。在本例中，它是被自动调用的。但也可以用super来指定对基类构造器的调用。
            
            基类构造器和导出类的构造器一样，以相同的顺序来经历相同的过程。在基类构造器完成之后，实例变量按其次序被初始化。最后，构造器的其余部分被执行。

    八、多态
        
        1. 多态通过分离做什么和怎么做，从另一角度将接口和实现分离开来。多态不但能够改善代码的组织结构和可读性，还能够创建可扩展的程序。
        
        2. “封装”通过合并特征和行为来创建新的数据类型。“实现隐藏”则通过将细节“私有化”把接口和实现分离开来。多态的作用则是消除类型之间和耦合关系。
        
            继承允许将对象视为它自己本身的类型或其基类型来处理。这种能力极为重要，因为它允许将多种类型（从同一基类导出的）视为同一类型来处理。
            
            而同一份代码也就可以毫无差别地运行在这些不同类型之上了。多态方法调用允许一种类型表现出与其他相似类型之间的区别，只要它们都是从同一基类导出来的。
            
            这种区别是根据方法行为的不同而表示出来的，虽然这些方法都可以通过同一个基类来调用。
            
        3. 再论向上转型。把对某个对象的引用视为对其基类型的引用的做法称为向上转型--因为在继承树的画法中，基类是放置在上方的。为什么我们要向上转型成基类引用呢？主要还是为了复用代码。
        
        4. 方法调用绑定。将一个方法调用同一个方法主体关联起来被称作绑定。若在程序执行前进行绑定（如果有的话，由编译器和连接程序实现），叫做前期绑定。
        
            但如果传入的参数一开始编译的时候只有基类的引用，编译器并不知道该去调用哪个方法。所以，解决的办法就是后期绑定。后期绑定的含义就是在运行时根据对象的类型进行绑定。
            
            后期绑定也叫做动态绑定或运行时绑定。如果一种语言想实现后期绑定，就必须具有某种机制，以便在运行时能判断对象的类型，从而调用恰当的方法。
            
            也就是说，编译器一直不知道对象的类型，但方法调用机制能找到正确的方法体，并加以调用。后期绑定机制随编程语言的不同而有所不同，但是只要想一下就会得知，不管怎样都必须在对象中安置某种“类型信息”。
            
            Java中除了static方法和final方法（private方法属于final方法）之外，其他所有的方法都是后期绑定。将方法声明为final后，可以防止其他人覆盖该方法。也可以有效地“关闭”动态绑定。
        
        5. 产生正确的行为。一旦知道Java中所有方法都是通过动态绑定实现多态之后，我们就可以编写只与基类打交道的代码了，并且这些代码对所有的导出类都可以正确运行。或者换一种说法，发送消息给某个对象，让该对象去断定应该做什么事。
           
        6. 可扩展性。由于有多态机制。我们就可以根据自己的需求对系统添任意多的新类型。而不需增加或更改go()方法。大多数或者所有方法都会遵守go()的模型，而且只与基类接口通信。
        
            这样的程序是可扩展的，因为可以从通用的基类继承出新的数据类型，从而新添一些功能。那些操纵基类接口的方法不需要任何改动就可以应用于新类。
        
        7. 缺陷：“覆盖”私有方法。
            
            由于private方法是自动认为是final方法，而且对导出类是屏蔽的。因此，这种情况下。Derived类中的f()方法就是一个全新的方法，基类中的f()方法在导出类Derived中不可见，因此也不能被重载。只有非private方法才可以被覆盖。在导出类中，对于基类中的private方法，最好采用不同的名字。
        
        8. 缺陷：域与静态方法。只有普通的方法是多态的。而且当一个方法是静态的，它的行为也就不具有多态性。静态方法是与类，而并非与单个对象相关联的。
        
        9. 构造器和多态。首先，构造器并不具有多态性。（它们实际上是static方法，只不过该static声明是隐式的）。
                                
            初始化的过程：
                
                1）在所有事物发生之前，将分配给对象的存储空间初始化为二进制的零。
                
                2）调用基类构造器。
                
                3）按照声明顺序调用成员的初始化方法。
                
                4）调用导出类（本体）的构造器主体。
        
        10. 继承与清理。通过组合和继承来创建新类时，永远不必担心对象的清理问题。子对象通常都会留给垃圾回收器进行处理。如果确实遇到问题，那么必须用心为新类创建dispose()方法。
        
            并且由于是继承的缘故，如果我们有其他作为垃圾回收一部分的特殊清理动作，就必须在导出类中覆盖dispose()方法。当覆盖被继承类的dispose()方法时，务必记住调用基类的super.dispose()方法。否则，基类的清理动作就不会发生。    
            
            注意，尽管通常不必执行清理工作，但是一旦选择执行就必须谨慎和小心！
            
        11. 协变返回类型。Java SE5中添加了协变返回类型，它表示在导出类的被覆盖方法可以返回基类方法的返回类型的某种导出类型。
        
        12. 用继承进行设计。当在使用现成的类来建立新类时，首先应当还是考虑“组合”。组合不会强制我们的程序设计进入继承的层次结构中，而且，组合更加灵活，因为它可以动态选择类型。
        
            相反，继承在编译时就需要知道确切类型。比如我new 一个Car 。我可以在程序运行过程中让它从奔驰变为宝马，也可以变成奥迪（这个也称为状态模式）。但是继承，我一旦new了，奔驰就是奔驰，并不能再变成宝马。我们不能在运行期间决定继承不同的对象。
            
            1）纯继承与扩展。纯继承：只有在基类中已经建立的方法才可以在导出类中覆盖。就是“is-a”的关系。因为一个类的接口已经确定了它应该是什么。继承可以确保所有的导出类具有基类的接口，且绝对不会少。
            
                这就是一种纯替代。因为导出类可以完全替代基类，使用时，完全不需要知道关于子类的任何额外信息。扩展：就是“is-like-a”的关系。因为导出类就像是一个基类--具有相同的基本接口，但是它还具有由额外方法实现的其他特性。
                
                虽然这是一种有用的方法，但还是要依赖于具体的情况。它的缺点是，导出类中接口的扩展部分不能被基类访问。因此一旦向上转型，就不能调用那些新方法。
            
            2）、向下转型与运行时类型识别。在Java中，所有转型都会得到检查。这些都是在运行期间对类型进行检查的行为。一般来说，如果你知道这个对象的具体类型，就可以尝试向下转型。如果所转类型是正确的，那么转型成功。如果是错误的，便会返回一个ClassCastException异常。
    
    九、接口
    
        1. 抽象类和抽象方法。
        
            包含抽象方法的类叫做抽象类。如果一个类包含一个或多个抽象方法，该类必须被限定为抽象的。（否则，编译器便会报错。）
        
            如果从一个抽象类继承，并想创建该新类的对象。那么就必须为基类中的所有抽象方法提供方法定义。如果不这样做，那么导出类便也是抽象类，且编译器将会强制我们用abstract关键字来限定这个类。
            
            创建抽象类和抽象方法非常有用，因为它们可以使类的抽象性明确起来，并告诉用户和编译器打算怎样来使用它们。抽象类还是很有用的重构工具，因为它们使得我们可以很容易地将公共方法沿着继承层级结构向上移动。
            
        2. 接口。
        
            interface关键字使抽象的概念更向前迈进了一步。abstract关键字允许人们在类中创建一个或多个没有任何定义的方法---提供了接口部分，但是没有提供任何相应的具体实现。这些实现是由此类的继承者创建的。interface这个关键字产生一个完全抽象的类，它根本就没有提供任何具体实现。
           
            可以选择在接口中显式地将方法声明为public的，但即使不这么做， 它们也是public的。因此，当要实现一个接口时，在接口中被定义的方法必须被定义为是public的。否则，它们将只能得到默认的包访问权限，这样在方法被继承的过程中，其可访问权限就被降低了，这是java编译器所不允许的。
           
            在接口中的每一个方法确实都是一个声明，这是编译器所允许的在接口中唯一存在的事物。
        
        3. 完全解偶。
        
            只要一个方法操作的是类而非接口。那么你就只能使用这个类及其子类。如果你想要将这个方法应用于不在此继承结构中的某个类，那么就不行了。接口可以在很大程度上放宽这种限制。因此，它可以使得我们编写复用性更好的代码。
            
            策略设计模式：创建一个能够根据所传递的参数对象的不同而具有不同行为的方法。这类方法包含所要执行的算法中固定不变的部分。而“策略”包含变化的部分。策略就是传递进去的参数对象，它包含要执行的代码。
            
            适配器设计模式：适配器中的代码将接受你所拥有的接口，并产生你所需要的接口。 
        
        4、Java中的多重继承。
        
            就是实现多个接口。这也是使用接口的核心原因，为了能够向上转型为多个基类型（以及由此带来的灵活性）。然后，使用接口的第二个原因却是与使用抽象基类相同：防止客户端程序员创建该类的对象，并确保这仅仅是建立一个接口。
         
            但这就带来一个问题，我们应该使用接口还是抽象类？如果要创建不带任何方法和成员变量的基类，那么就应该选择接口而不是抽象类。
        
        5. 通过继承来扩展接口。
        
            通过继承，可以很容易地在接口中添加新的方法声明，还可以通过继承在新接口中组合数个接口。
           
            组合接口时的名字冲突：可以重载方法，覆写方法写个@Override注解。尽量还是避免在不同的接口中使用相同的方法名造成代码可读性的混乱。    
        
        6. 接口中的域。
        
            放入接口中的任何域（字段）都自动是static和final的，同时也是自动public的。
            
            在接口中定义的域不能是“空final”的，但是可以被非常量表达式初始化。
            
            既然域是static的，它们就可以在类第一次被加载时初始化，这发生在任何域首次被访问时。当然，这些域不是接口的一部分，它们的值被存储在该接口的静态存储区域内。
            
        7. 接口嵌套。
         
            接口可以嵌套在类或其他接口中。
            
        8. 接口与工厂。
        
            工厂方法设计模式非常好用，复用代码很方便，与直接调用构造器不同，我们在工厂对象上调用的是创建方法。该工厂对象将生成接口的某个实现的对象。
    
    十、内部类
    
        1. 将一个类的定义放在另一个类的定义内部，这就是内部类。内部类是一种非常有用的特性，因为它允许你把一些逻辑相关的类组织在一起，并控制位于内部的类的可视性。
        
        2. 如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须像在main()方法中那样，具体地指明这个对象的类型：OuterClassName.InnerClassName。
        
            内部类拥有其外围类的所有元素的访问权。意思是通过内部类能够获得其外部类的内存信息（参数值）。故不能直接通过创建普通对象的方法创建内部类，必须要通过外部类才能创建。
        
        3. 链接到外部类。
           
            当生成一个内部类的对象时，此对象与制造它的外围对象之间就有了以一种联系。所以它能访问其外围对象的所有成员，而不需要任何特殊条件。此外，内部类还拥有其外围类的所有元素的访问权。
           
            这是如何做到的呢？当某个外围类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用。然后，在你访问此外围类的成员时，就是那个引用来选择外围类的成员。
        
        4. .new语法：可以直接创建其内部类，但前提也是要提供其外部类的引用（OuterClassObject.new InnerClassName()）。
            
            在拥有外部类对象之前是不可能创建内部类对象的。这是因为内部类对象会暗暗地连接到创建它的外部类对象上。但是，如果你创建的是嵌套类（静态内部类），那么它就不需要对外部类对象的引用。
            
        5. 内部类与向上转型。
        
            当将内部类向上转型为其基类，尤其是转型为一个接口的时候，内部类就有了用武之地。
            
            （从实现了某个接口的对象，得到对此接口的引用，与向上转型为这个对象的基类，实质上效果是一样的）这是因为此内部类---某个接口的实现---能够完全不可见，并且不可用。
            
            所得到的只是指向基类或接口的引用，所以能够很方便地隐藏实现细节。
        
        6. 在方法和作用域内的内部类。
        
            可以在一个方法里面或在任意的作用域内定义内部类。这么做有两个理由：
            
                1）如果实现了某类型的接口，于是可以创建并返回对其的引用。
                
                2）你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但是又不希望这个类是公共可用的。
            
            内部类可以嵌入在任何堆作用域内，但只在其作用域内可用。称作为局部内部类。
            
        7. 匿名内部类。
        
            匿名内部类是一个没有名字的内部类，通常使用它来简化代码编写，同时必须继承一个父类或实现一个接口。
            
            常用的扩展是将只使用一次的工厂类作为匿名内部类放在生产类上。
            
            如果定义一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器会要求其参数是final的。否则，编译器将会报错。如果只是传递给匿名类的基类的构造器，那么不需要将传入的形参定为final。
        
        8. 嵌套类。
        
            如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为static。这通常被称为嵌套类。
            
            想要理解static应用于内部类时的含义，就必须记住，普通的内部类对象隐式地保存了一个引用，指向创建它的外围类对象。然而，当内部类是static的时，就不是这样了。
            
            嵌套类意味着：
           
                1）要创建嵌套类的对象，并不需要其外围类的对象。
           
                2）不能从嵌套类的对象中访问非静态的外围类对象。
           
            嵌套类与普通的内部类还有一个区别，普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有static数据和static字段，也不能包含嵌套类。但是嵌套类可以包含所有这些东西。
           
            接口内部的类：正常情况下，不能在接口内部放置任何代码。但嵌套类可以作为接口的一部分。你放到接口中的任何类都自动是public和static的。因为类是static的，只是将嵌套类置于接口的命名空间内，这并不违反接口的规则。
            
            从多层嵌套类中访问外部类的成员：一个内部类被嵌套多少层并不重要--它能透明地访问所以它所嵌入的外围类的所有成员。
    
        9. 为什么需要内部类。
        
            一般来说，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外围类的对象。所以可以认为内部类提供了某种进入其外围类的窗口。
            
            每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。
            
            内部类允许继承多个非接口类型（类或抽象类）。
            
            内部类的特性：
            
                1）内部类可以有多个实例，每个实例都有自己的状态信息。并且与其外围类对象的信息相互独立。
                
                2）在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。
                
                3）创建内部类对象的时刻并不依赖于外围类对象的创建。
                
                4）内部类并没有令人迷惑的“is-a”关系；它就是一个独立的实体。
            
            闭包与回调：闭包是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。
            
            通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外围类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括private成员。
        
        10. 内部类的继承。
        
            因为内部类的构造器必须连接到指向其外围类对象的引用，所以在继承内部类的时候，事情会变得有点复杂。
            
            问题在于，那个指向外围类的“秘密的”引用必须被初始化，而在导出类中不再存在可连接的默认对象。
            
            要解决这个问题，必须使用特殊的语法来明确说清它们之间的关联：
            
                必须在构造器内使用如下语法：enclosingClassReference.super(); 这样才提供了必要的引用，然后程序才能编译通过。
        
        11. 内部类可以被覆盖吗？
        
            默认的构造器是编译器自动生成的，这里是调用基类的默认构造器。你可能认为既然创建了BigEgg的对象，那么所使用的应该是“覆盖后”的Yolk版本。
            
            但实际情况并不是这样。当继承了某个外围类的时候，内部类并没有发生什么特别神奇的变化。这两个内部类完全是独立的两个实体。各自在自己的命名空间内。当然，明确地继承某个内部类也是可以的。
        
        12. 局部内部类。
        
            可以在代码块中创建内部类。典型的方式是在一个方法体的里面创建。局部内部类不能有访问说明符，因为它不是外围类的一部分。但是它可以访问当前代码块内的常量以及此外围类的所有成员。
            
        13、内部类标识符。
        
            由于每个类都会产生一个.class文件，其中包含了如何创建该类型的对象的全部信息。（此信息产生一个“meta-class”，叫做Class对象）。
            
            内部类也必须生成一个.class文件以包含它们的Class对象信息。这些类文件的命名有严格的规则：外围类的名字，加上"$"，再加上内部类的名字。
            
            如果内部类是匿名的，编译器会简单地产生一个数字作为标识符。如果内部类是嵌套在别的内部类之中，只需直接将它们的名字加载其外围类标识符与“$”的后面。
    
    十一、持有对象
    
        1. 各种容器。
        
            ArrayList LinkedList 都是按插入顺序存放数据；
            
            ArrayList在随机访问速度上比较快，而LinkedList在插入和删除数据比较有优势，具有Queue，Stack的特性；
            
            HashSet TreeSet LinkedHashSet；
            
            HashMap TreeMap LinkedHashMap；
            
            通用点：Hash开头的容器都是通过Hash值来查找数据，所以特点是无序但速度快；
            
            Tree开头的容器都会将存入的数据进行升序排列；
            
            Linked则是按插入的顺序进行排序。  
        
        2. 迭代器
        
            具有以下特性：
                
                1）创建代价小，单向移动；
                
                2）使用方法iterator()要求容器返回一个Iterator。Iterator将准备好返回序列的第一个元素；
                
                3）使用next()获取序列中的下一个元素；
                
                4）使用hasNext()检查序列中是否还有元素；
                
                5）使用remove()移除由next()返回的元素。
           
            ListIterator 作为List特有的迭代器，具有双向移动功能，其对应方法为hasPrevious()，previous()，使用add()添加元素，set()修改最后一个访问的元素。
            
        3. 栈
           
           后进先出，通常可以使用LinkedList来实现Stack的功能。
           
        4. 队列
           
           先进先出，同样可以使用LinkedList来实现功能，由于其实现了Queue接口，可以将其向上转型。
        
        5. 优先队列
           
           PriorityQueue：简单来说就是具有排序功能的队列，下一个弹出的元素是在队列中优先级最高的一个。使用Comparator比较器来进行比较。
        
        6. foreach语法用于任何实现了Iterable接口的类。Collection接口扩展了Iterable接口，所以所有Collection对象都适用foreach语法。实现Collection就意味着需要提供iterator()方法。
        
    十二、通过异常处理错误
    
        1. 异常使用指南
        
            1）在恰当的级别处理问题（只在知道如何处理异常的时候才捕获异常）。
            
            2）解决问题并且重新调用产生异常的方法。
            
            3）进行少许修补，然后绕过异常发生的地方继续执行。
            
            4）用别的数据进行计算，以代替异方法预计会返回的值。
            
            5）把当前运行环境下能做的事情尽量做完，然后将相同的异常重抛到更高层。
            
            6）把当前运行环境下能做的事情尽量做完，然后将不同的异常重抛到更高层。
            
            7）终止程序。
            
            8）进行简化。
            
            9）让类库和程序更安全。
   
    十三、字符串
    
        1. String对象是不可变的。String类中每个看起来会修改String值的方法，实际上都是创建了一个全新的String对象，以包含修改后的字符串内容。而最初的String对象则丝毫未动。
        
        2. 用于String的“+”与“+=”是Java中仅有的两个重载过的运算符，Java不允许程序员重载任何运算符。
        
        3. String的不可变性带来了一定的效率问题，比如String的“+”运算，每“+”一次都会生成一个新的String对象。Java编译器一般会自动优化，但不同情况下，优化的程度不够。
        
        4. StringBuffer的内部实现方式和String不同，StringBuffer在进行字符串处理时，不生成新的对象，在内存使用上要优于String类。所以在实际使用时，如果经常需要对一个字符串进行修改，例如插入、删除等操作，使用StringBuffer要更加适合一些。
        
        5. 无意识的递归
        
            由String对象后面跟着一个“+”，再后面的对象不是String时，编译器会使后面的对象通过toString()自动类型转换成String，如果这发生在自定义的类的重写的toString()方法体内，就有可能发生无限递归，运行时抛出java.lang.StackOverflowError栈溢出异常。
            
            public class InfiniteRecursion{
                public String toString(){
                    //应该调用Object.toString()方法，所以此处应为super.toString()。
                    return " InfiniteRecursion address: " + this + "\n"; 
                }
                public static void main(String[] args){
                    List<InfiniteRecursion> v = new ArrayList<InfiniteRecursion>();
                    for(int i = 0; i < 10; i++)
                        v.add(new InfiniteRecursion());
                    System.out.println(v);
                }
            }
    
        6. String.format()方法用于创建格式化的字符串以及连接多个字符串对象。
        
        7. 正则表达式
        
            ？？？
        
        8. 扫描输入
        
            ？？？
        
        9. StringTokenizer
        
            Java中substring方法可以分解字符串，返回的是原字符串的一个子字符串。如果要将一个字符串分解为一个一个的单词或者标记，StringTokenizer可以帮你。
    
    十四、类型信息
    
        1. 
    
    
    
    
    
    
    
    
    
    
    
    
    参考文献：
    
        1. https://www.cnblogs.com/cpacm/p/5568405.html