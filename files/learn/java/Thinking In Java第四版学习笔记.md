####Thinking In Java第四版学习笔记

    一、对象导论
        
        万物皆为对象。
        
        程序是对象的集合，它们通过发送消息来告知彼此所要做的。
        
        每个对象都拥有其类型。
        
        某一特定类型的所有对象都可以接收同样的消息。

    二、一切都是对象 
                
        栈（堆栈）：存放基本类型变量和对象引用变量。位于RAM区
        
        堆：存放new得到的对象和数组。也位于RAM区
        
        常量存储：存放常量，包括静态变量。
        
        1. new出来的对象都是放在堆里的。
        
        2. 基本数据类型（boolean、 byte、char、short、Int、long、float、double、void）存放在栈（堆栈）里。 
        
        3. Java中的数值类型不存在无符号的，它们的取值范围是固定的，不会随着机器硬件环境或者操作系统的改变而改变。
        
        4. BigInteger任意精度整数；BigDecimal任意精度定点数（可用于货币汇率转换）。
        
    三、操作符
     
        1. 赋值表达式是有值的，赋值表达式的值等于要赋的值。
        
        2. 移位操作符：
           
            $<<$：操作数向左移动，低位补0；
            
            $>>$：操作数向右移动，(1)符号为正时，高位补0，(2)符号为负时，高位补1；
            
            $>>>$：java独有操作符，操作数向右移动，高位统一补0。
            
            char，byte，short进行移位操作时先会转成int类型，即32位。
        
        3.三元运算符：
                      
            条件表达式？表达式1：表达式2。
            
            说明：问号前面的位置是判断的条件，判断结果为bool型，为true时调用表达式1，为false时调用表达式2。
        
        4. 将float或double转型为整数值时，总是对数字进行截尾，不会进行四舍五入。如果想要得到舍入的结果可以使用Math.round()。
        
        5. 如果对基本数据类型执行算数运算或按位运算，只要类型比int小（即char、byte或者short），那么在运算之前，这些值会自动转化成int。
        
            这样一来，最终生成的结果就是int类型。如果想把结果赋值给较小的类型，就必须使用类型转化。通常，表达式中出现的最大的数据类型决定了表达式最终结果的数据类型。
            
            如果将一个float值与一个double值相乘，结果就是double，如果将一个int和一个long值相加，则结果为long。
    
    四、控制执行流程
    
        1. returan关键词的用途：指定一个方法返回什么值（假设它没有void返回值），退出当前方法，并返回那个值。
        
        2. break用于强行退出循环，不执行循环中剩余的语句。而continue则停止执行当前的迭代，然后退回到循环起始处，开始下一次迭代。
        
            1）一般的continue会退回到最内层循环的开头，并继续执行。
            
            2）带标签的continue会达到标签的位置，并重新进入紧接在那个标签后面的循环。
            
            3）一般的break会中断并跳出当前循环。
            
            4）带标签的break会中断并跳出标签所指的循环。
            
            使用标签的唯一目的，就是因为循环嵌套的存在。用于多层嵌套的break和continue。
            
        3. switch 语句由一个控制表达式和多个case标签组成。
                 
            1）能用于switch判断的类型有：byte、short、int、char（JDK1.6），还有枚举类型，但是在JDK1.7后添加了对String类型的判断;
            
            2）case语句中少写了break，编译不会报错，但是会一直执行之后所有case条件下的语句而不再判断，一旦case匹配，就会顺序执行后面的程序代码，而不管后面的case是否匹配，直到遇见break或者default语句。
            
            3）若果没有符合条件的case就执行default下的代码块，default并不是必须的，也可以不写.
    
    五、初始化与清理
    
        1. 重载
                
            重载主要以传入参数及顺序来区别。不能通过返回值来区别
            
            以基本数据类型传入时:自动包装机制
            
                1）若传入的数据类型小于方法中声明的形式参数类型，实际数据类型就会提升。
                    
                    byte -> short -> int -> long -> float -> double
                
                2）如果传入的实际参数较大，就得通过类型转换执行窄化转换。
        
        2. this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。
            
             1）表示当前对象的引用；
             
             2）this调用本类中的属性和方法，也就是类中的成员变量和方法；
             
             3）this调用本类中的其他构造方法，调用时要放在构造方法的首行。
        
        3. super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。
        
            1）主要存在于子类方法中，用于指向子类对象中父类对象；
            
            2）访问父类的属性；
            
            3）访问父类的函数；
            
            4）问父类的构造函数。
            
        注意：
        
            如果开发者自定义了一个类，没有显示的进行类的继承，那么该类中成员函数是否可以使用super关键字？可以使用，任何类默认继承了Object类，Object类是所有类的父类。
            
            this和super很像，this指向的是当前对象的调用，super指向的是当前调用对象的父类。
            
            类加载完毕，创建对象，父类的构造方法会被调用（默认自动无参），然后执行子类相应构造创建了一个子类对象，该子类对象还包含了一个父类对象。该父类对象在子类对象内部。
            
            this和super只能在有对象的前提下使用，不能在静态上下文使用。
            
        super和this的异同：
        
            super（参数）：调用基类中的某一个构造函数（应该为构造函数中的第一条语句） 
            
            this（参数）：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句）
            
            super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名    super.成员函数据名（实参）
            
            this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）
            
            调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。
            
            super()和this()类似，区别是，super()从子类中调用父类的构造方法，this()在同一类内调用其它方法。
            
            super()和this()均需放在构造方法内第一行。
            
            尽管可以用this调用一个构造器，但却不能调用两个。
            
            this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。
            
            this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量，static方法，static语句块。
            
            从本质上讲，this是一个指向本对象的指针， 然而super是一个Java关键字。
        
        4. static方法就是没有类中this的方法。
        
            在static方法的内部不能调用非静态方法，反之却可以。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。
            
        5. finalize()工作原理：一旦垃圾回收器准备释放对象占用的存储空间，将先调用其finalize()方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。所以你要是打算使用finalize()，就能在垃圾回收时刻做一些重要的清理工作。
            
            finalize方法，基本只会在java调用了native方法的时候，需要再通过native方法来释放它所占用的内存空间调用。
            
            finalize方法，是发生在jvm进行垃圾回收前调用的方法，所以这个方法所代表的含义就是在jvm垃圾回收前所需要做的有关于内存回收的操作。
            
            还有一种情况是，为了定位bug。
            
            对于finalize()方法的使用，就只有一条建议--------尽量不要使用！！！
            
        6. System.gc()用于强制进行终结动作。作用只是提醒虚拟机：程序员希望进行一次垃圾回收。但是它不能保证垃圾回收一定会进行，而且具体什么时候进行是取决于具体的虚拟机的，不同的虚拟机有不同的对策。
        
            不要使用gc函数，为了保持代码健壮姓（记得将不用的变量置为null），让虚拟机去管理内存。
        
        7. 垃圾回收
           
            1）垃圾收集算法的核心思想  
             
                Java语言建立了垃圾收集机制，用以跟踪正在使用的对象和发现并回收不再使用(引用)的对象。该机制可以有效防范动态内存分配中可能发生的两个危险：因内存垃圾过多而引发的内存耗尽，以及不恰当的内存释放所造成的内存非法引用。  

                垃圾收集算法的核心思想是：对虚拟机可用内存空间，即堆空间中的对象进行识别，如果对象正在被引用，那么称其为存活对象，反之，如果对象不再被引用，则为垃圾对象，可以回收其占据的空间，用于再分配。垃圾收集算法的选择和垃圾收集系统参数的合理调节直接影响着系统性能，因此需要开发人员做比较深入的了解。  
             
            2）触发主GC(Garbage Collector)的条件  
             
                JVM进行次GC的频率很高，但因为这种GC占用时间极短，所以对系统产生的影响不大。更值得关注的是主GC的触发条件，因为它对系统影响很明显。总的来说，有两个条件会触发主GC:  
             
                    ① 当应用程序空闲时，即没有应用线程在运行时，GC会被调用。因为GC在优先级最低的线程中进行，所以当应用忙时，GC线程就不会被调用，但以下条件除外。  
                    
                    ② Java堆内存不足时，GC会被调用。当应用线程在运行，并在运行过程中创建新对象，若这时内存空间不足，JVM就会强制地调用GC线程，以便回收内存用于新的分配。若GC一次之后仍不能满足内存分配的要求，JVM会再进行两次GC作进一步的尝试，若仍无法满足要求，则 JVM将报“out of memory”的错误，Java应用将停止。  

                由于是否进行主GC由JVM根据系统环境决定，而系统环境在不断的变化当中，所以主GC的运行具有不确定性，无法预计它何时必然出现，但可以确定的是对一个长期运行的应用来说，其主GC是反复进行的。  
             
            3）减少GC开销的措施  
             
               　根据上述GC的机制，程序的运行会直接影响系统环境的变化，从而影响GC的触发。若不针对GC的特点进行设计和编码，就会出现内存驻留等一系列负面影响。为了避免这些影响，基本的原则就是尽可能地减少垃圾和减少GC过程中的开销。具体措施包括以下几个方面:  
             
                (1) 不要显式调用System.gc()  
                
                    此函数建议JVM进行主GC，虽然只是建议而非一定，但很多情况下它会触发主GC，从而增加主GC的频率，也即增加了间歇性停顿的次数。  
                
                (2) 尽量减少临时对象的使用  
                
                    临时对象在跳出函数调用后，会成为垃圾，少用临时变量就相当于减少了垃圾的产生，从而延长了出现上述第二个触发条件出现的时间，减少了主GC的机会。  
                
                (3) 对象不用时最好显式置为Null  
                    
                    一般而言，为Null的对象都会被作为垃圾处理，所以将不用的对象显式地设为Null，有利于GC收集器判定垃圾，从而提高了GC的效率。  
                
                (4) 尽量使用StringBuilder，而不用String来累加字符串
                
                    由于String是固定长的字符串对象，累加String对象时，并非在一个String对象中扩增，而是重新创建新的String对象，如 Str5=Str1+Str2+Str3+Str4，这条语句执行过程中会产生多个垃圾对象，因为对次作“+”操作时都必须创建新的String对象，但这些过渡对象对系统来说是没有实际意义的，只会增加更多的垃圾。
                    
                    避免这种情况可以改用StringBuilder来累加字符串，因StringBuilder是可变长的，它在原有基础上进行扩增，不会产生中间对象。  
                
                (5) 能用基本类型如Int，Long，就不用Integer，Long对象  
                
                    基本类型变量占用的内存资源比相应对象占用的少得多，如果没有必要，最好使用基本变量。  
                
                (6) 尽量少用静态对象变量  
                
                    静态变量属于全局变量，不会被GC回收，它们会一直占用内存。  
                
                (7) 分散对象创建或删除的时间  
                
                    集中在短时间内大量创建新对象，特别是大对象，会导致突然需要大量内存，JVM在面临这种情况时，只能进行主GC，以回收内存或整合内存碎片， 从而增加主GC的频率。集中删除对象，道理也是一样的。它使得突然出现了大量的垃圾对象，空闲空间必然减少，从而大大增加了下一次创建新对象时强制主GC 的机会。

        8. 初始化顺序
           
            所有的变量都会在任何方法（包括构造器）被调用之前得到初始化。
            
            无论创建多少对象，静态数据都只占用一份存储区域，static不能作用于局部变量。且静态初始化动作只执行一次。
            
            成员初始化。初始化的顺序是，先静态对象，而后是“非静态对象”。对于方法的局部变量，如果没有初始化编译时会报未初始化的错。
           
            构造器初始化。可以使用构造器进行初始化，但是自动初始化将会在构造器被调用之前发生，给成员变量赋默认初始“零值”。
            
            静态数据的初始化。无论创建多少个对象，静态数据都只占用一份存储区域。static关键字不能应用于局部变量，因此它只能作用于域。如果一个域是静态的基本类型域，且也没有对它进行初始化。那么它会获得基本类型的标准初值。
            
            如果它是一个对象引用，那么它的默认初始值就是null。静态初始化动作只进行一次：当首次生成这个类的一个对象时，或者首次访问属于这个类的静态成员时（即便从未生成过那个类的对象）。
            
            数组初始化。数组只是相同类型的、用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。拥有的只是对数组的一个引用。数组的创建是在运行时刻进行的。可变参数列表。提供了一种方便的语法来创建对象并调用方法。由于所以的类都直接或间接继承于Object类，所以可以创建以Object数组为参数的方法。
            
            枚举类型。当创建枚举时，编译器会自动添加一些有用的特性，比如toString()方法，显示某个enum实例的名字。ordinal()方法，用来表示某个特定enum常量的声明顺序。static values()，用来按照enum常量的声明顺序，产生由这些常量值构成的数组。

        9. 可变参数列表
        
            定义：void method(Object... args){}
            
            调用：method()或method(new Object[]{1, 2, 3, 4});
    
    六、访问权限控制
    
        public的类、类属变量及方法，包内及包外的任何类均可以访问；
        
        protected的类、类属变量及方法，包内的任何类，及包外的那些继承了此类的子类才能访问；
        
        private的类、类属变量及方法，类自己的内部类可以访问，其他任何类均不能访问；
        
        如果一个类、类属变量及方法不以这三种修饰符来修饰，它就是friendly类型的，那么包内的任何类都可以访问它，而包外的任何类都不能访问它(包括包外继承了此类的子类)，因此，这种类、类属变量及方法对包内的其他类是友好的，开放的，而对包外的其他类是关闭的。

    七、复合类
    
        1. 子类实例化的时候会默认调用父类的无参构造函数。
        
        2. 确保正确清理。许多情况下，清理并不是问题，仅需让垃圾回收器完成该动作就行。但当必须亲自处理清理时，就要多加小心。因为，垃圾回收器可能永远也无法被调用，即时被调用，它是按照任何它想要的顺序来回收对象。最好的办法是除了内存以外，不能依赖垃圾回收器去做任何事。如果需要清理，就自己写一个清理方法，但不要使用finalize()。
        
        3. 当你选择覆写某个方法时，可以选择添加这个@Override注解。
           
        4. 在组合与继承之间选择。组合和继承都允许在新的类中放置子对象，组合是显式地这样做，而继承是隐式地做。一般来说很简单。如果是“is-a”的关系，那就使用继承。如果是“has-a”的关系，那就使用组合。
        
        6. protected关键字。在实际项目中，经常会想要将某些事物尽可能对这个世界隐藏起来，但仍允许子类的成员访问它们。这时候便可以使用protected关键字。
           
        7. 向上转型。子类引用向上转型成为基类引用。因为子类一定具有基类的方法。所以这种转型是肯定可以的。类接口唯一可能发生的事情是丢失方法，而不是获取它们。
        
        8. final。意味着不可修改！
        
            1）final数据。
            
                1、一个永远不变的编译时常量。
                 
                2、一个在运行时被初始化的值，但不会再被改变。这是针对于基本数据类型。如果当final修饰一个引用的时候，那是意味着这个引用永远不能再改变了，不能再指向其他对象，但是对象的内容是可以改变的。
                
                注意： 一个既是static又是final的字段只占据一段不能修改的存储空间。
            
            2）空白final。所谓空白final指被声明为final但又未给定初值的字段。但编译器必须确保空白final在使用前必须被初始化。所以必须在字段的定义处或者每个构造器中用表达式对final进行赋值。
            
            3）final参数。Java允许在参数列表中以声明的方式将参数指明为final。这意味着你无法在方法中更改参数引用所指向的对象。
            
            4）final方法。使用final方法有两个原因。
            
                1、把方法锁定，以防任何继承类修改它的含义。可以确保在继承中使方法行为保持不变，并且不会被覆盖。
                
                2、使用final限定方法时。等于同意编译器将针对这个方法的所有调用转为内嵌调用。但现在一般只有要明确禁止覆盖时，才将方法设置为final。
            
            5）final和private关键字。类中的所有private方法都隐式地指定为是final。由于无法取用private方法，所以也就无法覆盖它。对private方法添加final修饰词是没有什么意义的。
            
            6）final类。当将某个类的整体定义为final时（通过关键字final置于它的定义之前），就表明了你不打算继承该类，并且也不允许别人这么做。
        
        9. 初始化及类的加载。
        
            Java中的所有事物都是对象。所以它采用了不同的加载方式。每个类的编译代码都在它自己的独立的文件之中，该文件只有需要使用程序代码时才会被加载。“类的代码在初次使用时才加载”。
        
            这通常是指加载发生在创建类的第一个对象之时，但是当访问static域或static方法时，也发生加载。初次使用之处也是static初始化发生之处。
            
            所有的static对象和static代码段都会在加载时依程序中的顺序（即，类定义时的书写顺序）而依次初始化并且只会被初始化一次。
            
            其实构造器也是static方法，尽管static关键字并没有显式地写出来。因此更准确地讲，类是在其任何static成员被访问时加载的。
           
            运行一个类时的加载顺序是这样的：
            
                假设该类名为Bettle。首先访问Beetle.main()（一个static方法），于是加载器开始启动并找出Beetle类的编译代码（在名为Beetle.class的文件之中）。
           
            在对它进行加载的过程中，编译器注意到它有一个基类（这是由关键字extends得知的），于是它继续进行加载。不管你是否打算产生一个该基类的对象，这都要发生。如果该基类还有其自身的基类，那么第二个基类就会被加载，如此类推。
            
            接下来，根基类中的static初始化即会被执行，然后是下一个子类，以此类推。这种方式很重要，因为子类的static初始化可能会依赖于基类成员能否被正确初始化。至此，必要的类都有已经加载完毕。于是就可以开始创建对象。
            
            首先，对象中所有的基本类型都会被设为默认值，对象引用被设为null--这是通过将对象的内存设为二进制灵零值而一举产生的。然后，基类的构造器会被调用。在本例中，它是被自动调用的。但也可以用super来指定对基类构造器的调用。
            
            基类构造器和子类的构造器一样，以相同的顺序来经历相同的过程。在基类构造器完成之后，实例变量按其次序被初始化。最后，构造器的其余部分被执行。

        
        
        
        
        
    
    参考文献：
    
        1. https://www.cnblogs.com/cpacm/p/5568405.html