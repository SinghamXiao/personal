####Effective Java第二版学习笔记

    一、Java内存泄漏：长生命周期的对象持有短生命周期对象的引用
                  
        类自己管理内存；
        
        缓存；
        
        容器 / 静态集合类，当集合里面的对象属性被修改后，再调用remove()方法时不起作用；
        
        各种连接，数据库连接，网络连接(socket)和I/O连接；
        
        内部类和外部模块的引用；
        
        单例模式，当持有外部引用时；
        
        监听和其他回调。
    
    二、避免使用终结方法(finalizer)
      
        终结方法(finalizer)通常是不可预测的，也是很危险的，一般情况下是不必要的。
      
        不要把finalizer当成C++中析构函数的对应物。java中，当对象不可达时（即没有引用指向这个对象时），会由垃圾回收器来回收与该对象相关联的内存资源；而其他的内存资源，则一般由try-finally代码块来完成类似的工作。
        
        1.finalizer的缺点：
          
            1）终结方法的缺点在于不能保证会被及时地执行。
            
                及时执行finalizer方法是JVM垃圾回收方法的一个主要功能。由于不同JVM的垃圾回收算法不同，JVM会“非故意的”延迟执行终结方法，因此终结方法的执行时间点是非常不稳定的。
            
            2）finalizer方法的线程优先级比当前程序的其他线程优先级要低，且JAVA语言规范不保证哪个线程可以执行finalizer方法。
            
            3）JAVA语言规范不仅不保证及时执行finalizer方法，还不保证一定会执行finalizer方法。当程序终止时，有可能一些对象的finalizer方法还没有执行。——不应该依赖finalizer方法来更新重要的持久状态。
            
            4）System.gc和System.runFinalization不保证finalizer一定执行。
            
            5）System.runFinalizersOnExit Runtime.runFinalizersOnExit 可以保证finalizer一定执行，但是这两个方法已经废弃。
            
            6）如果未捕获的异常在finalizer方法中抛出来，这个异常可以被忽略（警告都不会打印出来），且finalizer方法会终止。这样这个异常就使对象处于“被破坏”的状态，如果另一个线程要使用这个对象，就可能发生不确定的行为。
            
            7）finalizer方法会有非常严重的（Severe）性能损失
    
        2. 终结方法的合法用途。
                       
            1）作为安全网——显示终止方法忘记调用的时候
            
            2）终止非关键的本地资源（android JNI操作中）
            
            终结方法的执行过程中要保证：如果子类的终结过程出现异常，超类的终结过程也会得到执行。
           
        总结：
        
            1）除非是作为安全网或者是为了终结非关键的本地资源，否则请不要使用终结方法。
            
            2）如果确实需要，可以使用显示终止方法
            
            3）如果没办法真的使用了finalize，别忘记了调用super.finalize()。还可以考虑是否使用终结方法守卫者，使未调用super.finalize()方法的类的父类的终结方法也会被执行。
    
    三、对于所有对象都通用的方法
    
        1. 谨慎地覆盖clone方法
    
            Cloneable接口的目的是作为对象的一个mixin接口(混合型接口)，表明这样的对象允许克隆(clone)。遗憾的是Cloneable接口里并没有clone方法，其实它什么方法都没有，跟Serializable接口一样，都是占着茅坑不拉屎。它只是声明该对象可以被克隆，具体行为由类设计者决定。如果类设计者忘记提供一个良好的clone方法或根本不提供clone方法，那么类客户使用时必定会出错，这样Cloneable接口并没达到它的目的。
        
            Cloneable接口决定了Object中受保护的clone方法的行为：如果一个类实现了Cloneable，Object的clone方法就返回该对象的逐域拷贝，否则就会抛出CloneNotSupportedException异常。这是接口的极端非典型的用法，不值得效仿，因为它违背了接口的使用规范，改变了超类中受保护的方法的行为。
        
            Cloneable接口约束实现类及其所有超类都必须遵守一种语言之外的机制：无需调用构造器就可以创建对象。通常这种机制的通用约定是非常弱的。它要求实现类和父类必须提供一个Clone方法，在Clone方法中调用super.clone方法，已达到最终调用Object.clone方法来完成约定。如果有一层没有按照约定实现，那么该类的Clone功能将是潜在的灾难。
            
            实现一个行为良好的clone方法
        
                @Override
                public PhoneNumber clone() {
                   try {
                       return (PhoneNumber) super.clone();//协变返回类型，永远不要让客户去做任何类库能够替他完成的事情。
                   } catch(CloneNotSupportedException e) {
                       throw new AssertionError();  // Can't happen
                   }
                }
            
            域中包含可变对象
        
                @Override
                public Stack clone() {
                   try {
                       Stack result = (Stack) super.clone();
                       result.elements = elements.clone();//递归调用clone。如果elements是final的，则需要把final去掉，因为final使得elements域不能被赋新值。另外，在数组上调用clone返回是数组，并且它的编译时类型与被克隆数组的类型相同。
                       return result;
                   } catch (CloneNotSupportedException e) {
                       throw new AssertionError();
                   }
                }
            
            Cloneable具有上述这么多的问题，那么可以肯定的说，其他的接口都不应该扩展这个接口，为了继承而设计的类也不应该实现这个接口。
            
            由于它具有这么多缺点，专家级的程序员从来不去覆盖clone方法，也从来不去调用它，除非拷贝数组。
           
            你必须清楚一点，对于一个专门为继承而设计的类，如果未能提供行为良好的受保护clone方法，它的子类就不可能实现Cloneable接口。
            
    四、类和接口
    
        1. 要么就为继承而设计，并提供文档说明，要么就禁止继承
        
            为了允许继承，类还必须遵守其他的一些约束。构造器决不能调用可被覆盖的方法，无论是直接调用还是间接调用。这是因为超类的构造器在子类的构造器之前运行，所以，子类中覆盖版本的方法将会在子类的构造器运行之前就先被调用。如果该覆盖版本的方法信赖于子类构造器所执行的任何初始化操作，该 方法将不会如预期执行。
            
            如果决定在一个为了继承而设计的类中实现Cloneable或者Serializable接口，就应该意识到，因为clone和readObject方法在行为非常类似于构造器，所以无论是clone还是readObject都不可以调用可覆盖的方法，不管是直接还是间接。对于readObject方法，覆盖版本的方法将在子类的状态被反序列化前被运行。对于clone方法，覆盖版本的方法则是在子类的clone方法有机会修正被克隆对象的状态之前被运行。无论哪种情况，都不可避免的导致程序失败。在clone方法的情形中，这种失败可能会同时损害到原始的对象以及被克隆的对象本身。
            
            最后，如果决定为继承而设计的类中实现Serializable，并且该类有一个readResolve或者writeReplace方法，就必须使readResolve或者writeReplace方法成员受保护的方法，而不是私有方法。这是因为私有的方法会被子类不声不响的忽略掉。
            
        2. 优先考虑静态成员类
           
            静态成员类是最简单的嵌套类，可以当做普通的类，只是被声明在另一个类的内部。
            
            非静态成员类的每个实例都隐含着与外部类的一个外部实例相关联。没有外部实例的情况下，是无法创建非静态成员类的实例。每个非静态成员类的实例都包含一个额外的指向外部对象的引用，会导致外部实例在垃圾回收时仍然保留。
            
            匿名类没有名字，在使用的同时被声明和实例化。当匿名类出现在非静态环境中时有外部实例，在静态环境中也不能拥有任何静态成员。匿名类必须保持简短，保持可读性。
            
            局部类，在任何可以声明局部变量的地方声明局部类，有名字，在非非静态环境中定义才有外部实例，不能包含静态成员，同时必须保持简短。
            
            总之，如果一个嵌套类需要在单个方法之外仍是可见的，或者它太长了，不适合放在方法内部，就应该使用成员类，如果成员类的每个实例都需要一个指向其外围实例的引用，就要把成员类做成非静态的。否则就做成静态的。假设这个嵌套类属于一个方法的内部，如果只需要在一个地方创建实例并且已经有了一个预置的类型可以说明这个类的特征，那就做成匿名类，否则就做成局部类。
            
    五、泛型
    
        1. 
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        