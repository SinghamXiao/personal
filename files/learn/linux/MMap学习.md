####MMap学习

        利用ioremap访问硬件，需要经过两次拷贝：
        
            1. 明确：不管是在用户空间还是在内核空间，软件一律不能去直接访问设备的物理地址；
    
            2. 在内核驱动中如果要访问设备的物理地址，需要利用ioremap将设备的物理地址映射到内核虚拟地址上（动态内存映射区），以后驱动程序访问这个内核虚拟地址就是在间接得访问设备的物理地址（MMU,TLB,TTW）
    
            3. 如果用户要访问硬件设备，不能直接访问，也不能在用户空间访问，只能通过系统调用(open,close,read,write,ioctl)来访问映射好的内核虚拟地址，通过这种间接的访问来访问硬件设备，但是如果设计到数据的拷贝，还需要借助4个内存拷贝函数！
        
        通过以上的分析，发现应用程序通过read,write,ioctl来访问硬件设备，它们都要经过两次的数据拷贝，一次是用户空间和内核空间的数据拷贝，另外一次是内核空间和硬件之
        
        间的数据拷贝，如果设备拷贝的数据量比较小，那么read，write,ioctl的两次数据拷贝的过程对系统的影响几乎可以忽略不计，如果设备的数据量非常大，例如显卡（独立），
        
        LCD屏幕（显存共享主存），摄像头，声卡这类设备涉及的数据量比较庞大，如果还是用read,write,ioctl进行访问设备数据，无形对系统的性能影响非常大。
        
        用户访问设备，最终其实涉及的用户和硬件，而read,write,ioctl本身会牵扯到内核，所以这些函数涉及2次的数据拷贝，用户要直接去访问硬件设备，只需要将硬件
        
        设备的物理地址信息映射到用户的虚拟地址空间即可，一旦完毕，不会在牵扯到内核空间，以后用户直接访问用户的虚拟地址就是在访问设备硬件，由2次的数据拷贝的
        
        转换为一次的数据拷贝。
        
        
        目的：将硬件物理地址映射到用户虚拟地址空间，由2次数据拷贝变成1次数据拷贝！
        
        总结：
            设备驱动的mmap实现主要是将一个物理设备的可操作区域（设备空间）映射到一个进程的虚拟地址空间。这样就可以直接采用指针的方式像访问内存的方式访问设备。
            
            在驱动中的mmap实现主要是完成一件事，就是实际物理设备的操作区域到进程虚拟空间地址的映射过程。同时也需要保证这段映射的虚拟存储器区域不会被进程当做一般的空间使用，因此需要添加一系列的保护方式。
            
    参考资料：
    
        1. http://blog.csdn.net/zqixiao_09/article/details/51088478
        
        2. https://segmentfault.com/a/1190000003063859